// FSS signal moved from PA6 to PA3
// Move some functions to headstage.h, such as initialization and bandwidth selection code;

// Re-write channel select algorithm; mark result with channel number;

#include <stdint.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include "inc/hw_memmap.h"
#include "inc/hw_ints.h"
#include "inc/hw_ssi.h"
#include "inc/hw_types.h"
#include "inc/hw_gpio.h"

#include "utils/cmdline.h"
#include "utils/uartstdio.h"
#include "utils/uartstdio.c"
#include "driverlib/fpu.h"
#include "driverlib/gpio.h"
#include "driverlib/interrupt.h"
#include "driverlib/pin_map.h"
#include "driverlib/rom.h"
#include "driverlib/sysctl.h"
#include "driverlib/systick.h"
#include "driverlib/timer.h"
#include "driverlib/uart.h"
#include "driverlib/adc.h"
#include "driverlib/interrupt.h"
#include "driverlib/debug.h"
#include "driverlib/ssi.h"

#include "ff.h"
#include "diskio.h"
#include "headstage.h"
#include "icm20948.h"

/* ------------------------------------          Macros        ---------------------------------- */
#define LED_R GPIO_PIN_7 // red LED
#define LED_G GPIO_PIN_6 // red LED
#define RHS_BUFFER_A 0
#define RHS_BUFFER_B 1
#define ICM_BUFFER_A 0
#define ICM_BUFFER_B 1
//TODO:Read from confighd.txt
#define ICM_SAMPLING_FREQUENCY (200)

#define DEBUG 1;
// the error routine that is called if the driver library encounters an error
#ifdef DEBUG
void
__error__(char *pcFilename, uint32_t ui32Line)
{
}
#endif


/* ------------------------------------          Global Variables        ---------------------------------- */
// Buffers for Headstage data
uint16_t *RHS_bufferA;
uint16_t *RHS_bufferB;
uint32_t RHS_buffer_size;
volatile bool RHS_bufferA_empty;
volatile bool RHS_bufferB_empty;
volatile bool RHS_buffer_mode;
volatile bool RHS_storage_on;
uint16_t count;
uint16_t dummy;

// Headstage Stimulator
uint32_t pui32DataRx[1];
uint32_t channel_number;
uint32_t channel[32];

// Track if stimulator is started or not
bool stim_setup = false;
int stim_state[16] = {[0 ... 15] = 0};

// Buffers for ICM data
uint16_t *ICM_bufferA;
uint16_t *ICM_bufferB;
uint32_t ICM_buffer_size;
volatile bool ICM_bufferA_empty;
volatile bool ICM_bufferB_empty;
volatile bool ICM_buffer_mode;
volatile bool ICM_storage_on;
int ICM_buffer_len;

// ICM Sampling Freq
uint32_t ICM_sampling_frequency;
int ICM_sample_num;

// ICM gyro and accel axises
axises gyro_axises;
axises accel_axises;
struct axises_sign{
    char x[2];
    char y[2];
    char z[2];
};

// While (!stop) {}
bool stop = 0;

/*Variable required for SD Card R/W*/
FATFS fatfs;
FIL fil;
FIL fil_icm;
FRESULT rc;
UINT br, bw;


/************************************************/
/* stimulation command generated by timer1 */
/************************************************/
uint16_t sti_command_upper;
uint16_t sti_command_lower;

//use new variables for stimulation channel (copy way it's done with recording chan)
uint32_t sti_channel_number;
uint32_t sti_channel[32];

uint32_t stim_period[16];
uint32_t pos_pulse_width[16];
uint32_t neg_pulse_width[16];
uint32_t stim_off_time[16];

uint32_t sti_channel_all_mask = 0;
uint32_t sti_channel_current_mask = 0;

uint32_t sti_channel_masks_arr[16] = {[0 ... 15] = 0};  //array of masks for each channel
uint32_t neg_sti_channel_mask = 0;   //mask for keeping track of stimulators are set negative at any moment
uint32_t on_sti_channel_mask = 0;    //mask for keeping track of stimulators that are on
uint32_t pos_sti_channel_mask = 0;   //mask for keeping track of stimulators are set postive at any moment
uint32_t off_sti_channel_mask = 0;   //mask for keeping track of stimulators that are off

/* ------------------------------------         Functions        ---------------------------------- */
// function to send data to headstage
void SPI_Send(uint32_t data_MS, uint32_t data_LS)
{
    // pull-down the FSS signal and delay for some time
    ROM_GPIOPinWrite(GPIO_PORTA_BASE, GPIO_PIN_3, 0);
    ROM_SysCtlDelay(1);

    ROM_SSIDataPut(SSI0_BASE, data_MS);
    ROM_SSIDataPut(SSI0_BASE, data_LS);

    // wait until the data is fully transferred
    while(ROM_SSIBusy(SSI0_BASE))
    {
    }

    // delay for some time and pull-up the FSS signal
    ROM_SysCtlDelay(1);
    ROM_GPIOPinWrite(GPIO_PORTA_BASE, GPIO_PIN_3, 0b0001000);
}

// function to read register value and compare it with expected value
int read_check(uint32_t address, uint32_t expected_value)
{
    uint32_t DataRx_check[1]; // variable for receiving data

    SPI_Send((0b1100000000000000 | address), 0b0000000000000000);

    SPI_Send((0b1100000000000000 | address), 0b0000000000000000);
    // clear the receive FIFO
    while(ROM_SSIDataGetNonBlocking(SSI0_BASE, &pui32DataRx[0]))
    {
        // do nothing
    }

    SPI_Send((0b1100000000000000 | address), 0b0000000000000000);

    // collect the reading result
    ROM_SSIDataGetNonBlocking(SSI0_BASE, &DataRx_check[1]);
    ROM_SSIDataGetNonBlocking(SSI0_BASE, &DataRx_check[0]);

    if(! (DataRx_check[1] == 0x0000) ){
        return 0;
    }else{}
    if(! (DataRx_check[0] == expected_value) ){
        return 0;
    }else{}

    return 1;
}

void read_register(uint32_t address)
{
    uint32_t DataRx_check[1]; // variable for receiving data

    SPI_Send((0b1100000000000000 | address), 0b0000000000000000);

    SPI_Send((0b1100000000000000 | address), 0b0000000000000000);
    // clear the receive FIFO
    while(ROM_SSIDataGetNonBlocking(SSI0_BASE, &pui32DataRx[0]))
    {
        // do nothing
    }

    SPI_Send((0b1100000000000000 | address), 0b0000000000000000);

    // collect the reading result
    ROM_SSIDataGetNonBlocking(SSI0_BASE, &DataRx_check[1]);
    ROM_SSIDataGetNonBlocking(SSI0_BASE, &DataRx_check[0]);

    char filename[16];
    sprintf(filename, "%s%d", "%s", DataRx_check[0]);
    UARTprintf(filename);
    UARTprintf("\n");
}

uint32_t my_read_register(uint32_t address)
{
    uint32_t DataRx_check[1]; // variable for receiving data

    SPI_Send((0b1100000000000000 | address), 0b0000000000000000);

    SPI_Send((0b1100000000000000 | address), 0b0000000000000000);
    // clear the receive FIFO
    while(ROM_SSIDataGetNonBlocking(SSI0_BASE, &pui32DataRx[0]))
    {
        // do nothing
    }

    SPI_Send((0b1100000000000000 | address), 0b0000000000000000);

    // collect the reading result
    ROM_SSIDataGetNonBlocking(SSI0_BASE, &DataRx_check[1]);
    ROM_SSIDataGetNonBlocking(SSI0_BASE, &DataRx_check[0]);
    uint32_t result = DataRx_check[0] + DataRx_check[1];
    return result;

//what is this even for????????????????????
//    char filename[16];
//    sprintf(filename, "%s%d", "%s", DataRx_check[0]);
//    UARTprintf(filename);
//    UARTprintf("\n");
}

UARTprintfICM(axises accel_axises, axises gyro_axises)
{
    static struct axises_sign gyro_sign;
    static struct axises_sign accel_sign;

    // Interesting findings that the following sprintf() doesn't work in this ISR.
    // Reasons might be that it hangs the ISR and takes too long time.
    (uint16_t) accel_axises.x < 0x1fff ? strcpy(accel_sign.x, "+") : strcpy(accel_sign.x, "-");
    (uint16_t) accel_axises.y < 0x1fff ? strcpy(accel_sign.y, "+") : strcpy(accel_sign.y, "-");
    (uint16_t) accel_axises.z < 0x1fff ? strcpy(accel_sign.z, "+") : strcpy(accel_sign.z, "-");
    accel_axises.x = (uint16_t) accel_axises.x < 0x1fff ? (uint16_t) accel_axises.x : 0xffff - (uint16_t) accel_axises.x;
    accel_axises.y = (uint16_t) accel_axises.y < 0x1fff ? (uint16_t) accel_axises.y : 0xffff - (uint16_t) accel_axises.y;
    accel_axises.z = (uint16_t) accel_axises.z < 0x1fff ? (uint16_t) accel_axises.z : 0xffff - (uint16_t) accel_axises.z;

    (uint16_t) gyro_axises.x < 0x1fff ? strcpy(gyro_sign.x, "+") : strcpy(gyro_sign.x, "-");
    (uint16_t) gyro_axises.y < 0x1fff ? strcpy(gyro_sign.y, "+") : strcpy(gyro_sign.y, "-");
    (uint16_t) gyro_axises.z < 0x1fff ? strcpy(gyro_sign.z, "+") : strcpy(gyro_sign.z, "-");
    gyro_axises.x = (uint16_t) gyro_axises.x < 0x1fff ? (uint16_t) gyro_axises.x : 0xffff - (uint16_t) gyro_axises.x;
    gyro_axises.y = (uint16_t) gyro_axises.y < 0x1fff ? (uint16_t) gyro_axises.y : 0xffff - (uint16_t) gyro_axises.y;
    gyro_axises.z = (uint16_t) gyro_axises.z < 0x1fff ? (uint16_t) gyro_axises.z : 0xffff - (uint16_t) gyro_axises.z;

    UARTprintf("Accel axises (x, y, z) = (%s%d, %s%d, %s%d) ", accel_sign.x, (uint16_t) accel_axises.x,
                   accel_sign.y, (uint16_t) accel_axises.y, accel_sign.y, (uint16_t) accel_axises.z);
    UARTprintf("Gyro axises (x, y, z) = (%s%d, %s%d, %s%d) \n", gyro_sign.x, (uint16_t) gyro_axises.x,
                   gyro_sign.y, (uint16_t) gyro_axises.y, gyro_sign.z, (uint16_t) gyro_axises.z);

}

/* ------------------------------------          Interrupt Handlers        ---------------------------------- */
// SW 1 and 2 are used to stop the main while loop
void GPIOPortFHandler(void)
{
    UARTprintf("Entered GPIOF IRQ \n ");
    stop = 1;

    // Clear interrupt flag
    GPIOIntClear(GPIO_PORTF_BASE, GPIO_PIN_4 | GPIO_PIN_0);
    UARTprintf("Exit GPIOF IRQ \n ");
}


/* ------------------------------------          UART         ---------------------------------- */
// function to initialize onboard UART.
void uart_init(void)
{
    // enable uart gpio.
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA);

    // configure gpio pins as uart.
    // Port A0 is used for UART data receiving, and A1 is used for UART data transmitting
    ROM_GPIOPinConfigure(GPIO_PA0_U0RX);
    ROM_GPIOPinConfigure(GPIO_PA1_U0TX);

    // enable the uart module.
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_UART0);

    // set clock for baud rate generation.
    ROM_UARTClockSourceSet(UART0_BASE, UART_CLOCK_SYSTEM);

    // set pin type to uart.
    ROM_GPIOPinTypeUART(GPIO_PORTA_BASE, GPIO_PIN_0 | GPIO_PIN_1);

    // configure uart 0 at 115200 bps.
    UARTStdioConfig(0, 115200, SysCtlClockGet());
}


/* ------------------------------------          SPI         ---------------------------------- */
// function to initialize SSI module
void ICM_SPI_init(void)
{
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_SSI0);

    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA);
    // ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOC);

    ROM_GPIOPinConfigure(GPIO_PA2_SSI0CLK);
    // ROM_GPIOPinConfigure(GPIO_PC4_SSI0FSS);
    ROM_GPIOPinConfigure(GPIO_PA4_SSI0RX);
    ROM_GPIOPinConfigure(GPIO_PA5_SSI0TX);

    // port A3 is used for FSS output
    ROM_GPIOPinTypeGPIOOutput(GPIO_PORTA_BASE, GPIO_PIN_3);
    ROM_GPIOPinWrite(GPIO_PORTA_BASE, GPIO_PIN_3, 0b0001000);

    ROM_GPIOPinTypeSSI(GPIO_PORTA_BASE, GPIO_PIN_5 | GPIO_PIN_4 | GPIO_PIN_2);
    // ROM_GPIOPinTypeSSI(GPIO_PORTC_BASE, GPIO_PIN_4);

    ROM_SSIConfigSetExpClk(SSI0_BASE, ROM_SysCtlClockGet(), SSI_FRF_MOTO_MODE_0, SSI_MODE_MASTER, 10000000, 16);

    ROM_SSIEnable(SSI0_BASE);

    while(ROM_SSIDataGetNonBlocking(SSI0_BASE, &pui32DataRx[0]))
    {
        // clear the receive FIFO
    }
}


/* ------------------------------------          Pushbutton        ---------------------------------- */
// Pushbutton init - Would affect UARTprintf somehow - fix it later
void SW_int_init(void){
// Remove the Lock present on Switch SW2 (connected to PF0) and commit the change
   HWREG(GPIO_PORTF_BASE + GPIO_O_LOCK) = GPIO_LOCK_KEY;
   HWREG(GPIO_PORTF_BASE + GPIO_O_CR) |= GPIO_PIN_4;

   // Set the System clock to 50MHz and enable the clock for peripheral PortF.
   ROM_SysCtlClockSet(SYSCTL_SYSDIV_4 | SYSCTL_USE_PLL | SYSCTL_OSC_INT | SYSCTL_MAIN_OSC_DIS); // 50MHz System Clock

   // Configure input for PF4(SW1) and PF0(SW2)
   ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);
   ROM_GPIOPinTypeGPIOInput(GPIO_PORTF_BASE, GPIO_PIN_4);

   // Set up IRQ for PortF 4 |0
   GPIOIntRegister(GPIO_PORTF_BASE, GPIOPortFHandler);
   ROM_GPIOIntTypeSet(GPIO_PORTF_BASE,  GPIO_PIN_4, GPIO_FALLING_EDGE);
   GPIOIntEnable(GPIO_PORTF_BASE, GPIO_PIN_4);

   // Connect PF0, PF4 to internal Pull-up resistors and set 2 mA as current strength.
   ROM_GPIOPadConfigSet(GPIO_PORTF_BASE, GPIO_PIN_4, GPIO_STRENGTH_2MA, GPIO_PIN_TYPE_STD_WPU);
}

/* ------------------------------------          Timers        ---------------------------------- */

// Timer0 is used for triggering SPI data transfer
void timer0_init(uint32_t frequency)
{
    // Enable the timer peripheral
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_TIMER0);

    // Timer should run periodically
    // Full-width periodic timer
    ROM_TimerConfigure(TIMER0_BASE, TIMER_CFG_PERIODIC);

    // Set the compare value of the timer
    // This corresponds to the sampling frequency
    ROM_TimerLoadSet(TIMER0_BASE, TIMER_A, (ROM_SysCtlClockGet()/frequency)-1);

    // Enable the timer interrupt
    ROM_TimerIntEnable(TIMER0_BASE, TIMER_TIMA_TIMEOUT);
    ROM_IntEnable(INT_TIMER0A);

    // Enable Timer0
    ROM_TimerEnable(TIMER0_BASE, TIMER_A);

}

// Timer1 is used for delivering stimulation for first channel
// Timer1 load should be manually set
void timer1_init(void)
{
    // Enable the timer peripheral
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_TIMER1);

    // Timer should run periodically
    // Full-width periodic timer
    ROM_TimerConfigure(TIMER1_BASE, TIMER_CFG_PERIODIC);

    // Enable the timer interrupt
    ROM_TimerIntEnable(TIMER1_BASE, TIMER_TIMA_TIMEOUT);
    ROM_IntEnable(INT_TIMER1A);
}
// Timer2 is used for delivering stimulation for second channel
// Timer2 load should be manually set
void timer2_init(void)
{
    // Enable the timer peripheral
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_TIMER2);

    // Timer should run periodically
    // Full-width periodic timer
    ROM_TimerConfigure(TIMER2_BASE, TIMER_CFG_PERIODIC);

    // Enable the timer interrupt
    ROM_TimerIntEnable(TIMER2_BASE, TIMER_TIMA_TIMEOUT);
    ROM_IntEnable(INT_TIMER2A);
}
// Timer3 is used for delivering stimulation for third channel
// Timer3 load should be manually set
void timer3_init(void)
{
    // Enable the timer peripheral
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_TIMER3);

    // Timer should run periodically
    // Full-width periodic timer
    ROM_TimerConfigure(TIMER3_BASE, TIMER_CFG_PERIODIC);

    // Enable the timer interrupt
    ROM_TimerIntEnable(TIMER3_BASE, TIMER_TIMA_TIMEOUT);
    ROM_IntEnable(INT_TIMER3A);
}
// Timer4 is used for delivering stimulation for fourth channel
// Timer4 load should be manually set
void timer4_init(void)
{
    // Enable the timer peripheral
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_TIMER4);

    // Timer should run periodically
    // Full-width periodic timer
    ROM_TimerConfigure(TIMER4_BASE, TIMER_CFG_PERIODIC);

    // Enable the timer interrupt
    ROM_TimerIntEnable(TIMER4_BASE, TIMER_TIMA_TIMEOUT);
    ROM_IntEnable(INT_TIMER4A);
}
// Timer5 is used for triggering ICM gyro and accel SPI reading
void timer5_init(uint32_t frequency)
{
    // Enable the timer peripheral
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_TIMER5);

    // Timer should run periodically
    // Full-width periodic timer
    ROM_TimerConfigure(TIMER5_BASE, TIMER_CFG_PERIODIC);

    // Set the compare value of the timer
    // This corresponds to the sampling frequency
    ROM_TimerLoadSet(TIMER5_BASE, TIMER_A, (ROM_SysCtlClockGet()/frequency)-1);

    // Enable the timer interrupt
    ROM_TimerIntEnable(TIMER5_BASE, TIMER_TIMA_TIMEOUT);
    ROM_IntEnable(INT_TIMER5A);

    // Enable Timer5
    ROM_TimerEnable(TIMER5_BASE, TIMER_A);

}

/* ------------------------------------          Timer Handlers       ---------------------------------- */

// systick handler for FatFs library
void
SysTickHandler(void)
{
    ROM_SysTickIntDisable();
    disk_timerproc();
    ROM_SysTickIntEnable();
}

// Handler for timer0
void Timer0IntHandler(void) {
    // SW interrupt to stop the program
    if (stop)
    {
        ROM_TimerDisable(TIMER4_BASE, TIMER_A);
    }

    //setup in the timer0 interrupt to make the code work

    // clear the timer interrupt
    ROM_TimerIntClear(TIMER0_BASE, TIMER_TIMA_TIMEOUT);
    //ROM_TimerLoadSet(TIMER1_BASE, TIMER_A, (ROM_SysCtlClockGet()/1000000)-1); // re-set timer1 load

    uint32_t ADCValue[1];

    static uint16_t channel_count = 0;

    // do one convert
    SPI_Send(channel[channel_count], 0);

    if(channel_count < channel_number-1){
        channel_count += 1;
    }else{
        channel_count = 0;
    }

    // read conversion result from FIFO
    ROM_SSIDataGetNonBlocking(SSI0_BASE, &ADCValue[0]); //high gain amplifier result
    ROM_SSIDataGetNonBlocking(SSI0_BASE, &ADCValue[1]);

    if(RHS_bufferA_empty || RHS_bufferB_empty) { // check if any buffer is empty or has space
        if(RHS_buffer_mode == RHS_BUFFER_A) {
            RHS_bufferA[count] = ADCValue[0];
        }
        else if(RHS_buffer_mode == RHS_BUFFER_B) {
            RHS_bufferB[count] = ADCValue[0];
        }

        count = count + 1; // increment count for data in buffer
        if(count == RHS_buffer_size) { // check if count equals buffer_size, or if the buffer is full
            count = 0;

            // switch buffer mode and enable storage on SD card
            if(RHS_buffer_mode == RHS_BUFFER_A)
            {
                RHS_buffer_mode = RHS_BUFFER_B;
                RHS_bufferA_empty = false;
                RHS_storage_on = true;
            }
            else if(RHS_buffer_mode == RHS_BUFFER_B) {
                RHS_buffer_mode = RHS_BUFFER_A;
                RHS_bufferB_empty = false;
                RHS_storage_on = true;
            }
        }
    }

    // nonsense, added to make the code work
    if(RHS_bufferA_empty || RHS_bufferB_empty) { // check if any buffer is empty or has space
        if(RHS_buffer_mode == RHS_BUFFER_A) {
            RHS_bufferA[count] = ADCValue[0];
        }
        else if(RHS_buffer_mode == RHS_BUFFER_B) {
            RHS_bufferB[count] = ADCValue[0];
        }
    }
}

// Handler for timer1
void Timer1IntHandler(void) {
    // SW interrupt to stop the program
    if (stop)
    {
        ROM_TimerDisable(TIMER4_BASE, TIMER_A);
    }
    ROM_TimerIntClear(TIMER1_BASE, TIMER_TIMA_TIMEOUT);
    //UARTprintf("Inside Timer 1\n\n\n\n\n\n");
    //ROM_TimerLoadSet(TIMER1_BASE, TIMER_A, (ROM_SysCtlClockGet()-1));
    uint32_t result;
        switch(stim_state[0]){
        case 0:
            //toggle stimulation polarity to negative
            //clear bit in sti_command_lower
            result = my_read_register(44);
            //UARTprintf("result is:%d\n\n", result);
            result = (result & ~sti_channel_masks_arr[0]);
            sti_command_lower = result;
            sti_command_upper = 0b1010000000101100;
            SPI_Send(sti_command_upper, sti_command_lower);
            while(ROM_SSIDataGetNonBlocking(SSI0_BASE, &pui32DataRx[0]))
            {
            }
            // turn on stimulator
            //set bits in sti_command_lower
            result = my_read_register(42);
            result = (result | sti_channel_masks_arr[0]);
            //uint32_t channels_command = (1 << sti_channel[0])| (1 << sti_channel[1]);
            sti_command_lower = result;
            sti_command_upper = 0b1010000000101010;
            SPI_Send(sti_command_upper, sti_command_lower);
            while(ROM_SSIDataGetNonBlocking(SSI0_BASE, &pui32DataRx[0]))
            {
            }
           // int pos_pulse_width = pos_pulse_width_temp;
            //UARTprintf("pos_pulse_width = %d\n\n",pos_pulse_width);
            ROM_TimerLoadSet(TIMER1_BASE, TIMER_A, (ROM_SysCtlClockGet()/1000000)*neg_pulse_width[0]-1);
            stim_state[0]++;
            break;
        case 1:
            // toggle stimulation polarity to positive
            //set bits in sti_command_lower
            result = my_read_register(44);
            result = (result | sti_channel_masks_arr[0]);
            sti_command_lower = result;
            sti_command_upper = 0b1010000000101100;
            SPI_Send(sti_command_upper, sti_command_lower);
            while(ROM_SSIDataGetNonBlocking(SSI0_BASE, &pui32DataRx[0]))
            {
            }
            ROM_TimerLoadSet(TIMER1_BASE, TIMER_A, (ROM_SysCtlClockGet()/1000000)*pos_pulse_width[0]-1);
            stim_state[0]++;
            break;
        case 2 :
            // turn off stimulator
            // clear bits in sti_command_lower
            result = my_read_register(42);
            result = (result & ~sti_channel_masks_arr[0]);
            sti_command_lower = result;
            sti_command_upper = 0b1010000000101010;
            SPI_Send(sti_command_upper, sti_command_lower);
            while(ROM_SSIDataGetNonBlocking(SSI0_BASE, &pui32DataRx[0]))
            {
            }
            ROM_TimerLoadSet(TIMER1_BASE, TIMER_A, (ROM_SysCtlClockGet()/1000000)*stim_off_time[0]-1);
            stim_state[0] = 0;
            break;
        default:
            break;
        }
}

// Handler for timer2
void Timer2IntHandler(void) {
    // SW interrupt to stop the program
    if (stop)
    {
        ROM_TimerDisable(TIMER4_BASE, TIMER_A);
    }

    ROM_TimerIntClear(TIMER2_BASE, TIMER_TIMA_TIMEOUT);
    //UARTprintf("Inside Timer 2\n\n\n\n\n\n");
    //ROM_TimerLoadSet(TIMER2_BASE, TIMER_A, (ROM_SysCtlClockGet()-1));
    uint32_t result;
        switch(stim_state[1]){
        case 0:
            //toggle stimulation polarity to negative
            //clear bit in sti_command_lower
            result = my_read_register(44);
            result = (result & ~sti_channel_masks_arr[1]);
            sti_command_lower = result;
            sti_command_upper = 0b1010000000101100;
            SPI_Send(sti_command_upper, sti_command_lower);
            while(ROM_SSIDataGetNonBlocking(SSI0_BASE, &pui32DataRx[0]))
            {
            }
            // turn on stimulator
            //set bits in sti_command_lower
            result = my_read_register(42);
            result = (result | sti_channel_masks_arr[1]);
            //uint32_t channels_command = (1 << sti_channel[0])| (1 << sti_channel[1]);
            sti_command_lower = result;
            sti_command_upper = 0b1010000000101010;
            SPI_Send(sti_command_upper, sti_command_lower);
            while(ROM_SSIDataGetNonBlocking(SSI0_BASE, &pui32DataRx[0]))
            {
            }
           // int pos_pulse_width = pos_pulse_width_temp;
            //UARTprintf("pos_pulse_width = %d\n\n",pos_pulse_width);
            ROM_TimerLoadSet(TIMER2_BASE, TIMER_A, (ROM_SysCtlClockGet()/1000000)*neg_pulse_width[1]-1);
            stim_state[1]++;
            break;
        case 1:
            // toggle stimulation polarity to positive
            //set bits in sti_command_lower
            result = my_read_register(44);
            result = (result | sti_channel_masks_arr[1]);
            sti_command_lower = result;
            sti_command_upper = 0b1010000000101100;
            SPI_Send(sti_command_upper, sti_command_lower);
            while(ROM_SSIDataGetNonBlocking(SSI0_BASE, &pui32DataRx[0]))
            {
            }
            ROM_TimerLoadSet(TIMER2_BASE, TIMER_A, (ROM_SysCtlClockGet()/1000000)*pos_pulse_width[1]-1);
            stim_state[1]++;
            break;
        case 2 :
            // turn off stimulator
            // clear bits in sti_command_lower
            result = my_read_register(42);
            result = (result & ~sti_channel_masks_arr[1]);
            sti_command_lower = result;
            sti_command_upper = 0b1010000000101010;
            SPI_Send(sti_command_upper, sti_command_lower);
            while(ROM_SSIDataGetNonBlocking(SSI0_BASE, &pui32DataRx[0]))
            {
            }
            ROM_TimerLoadSet(TIMER2_BASE, TIMER_A, (ROM_SysCtlClockGet()/1000000)*stim_off_time[1]-1);
            stim_state[1] = 0;
            break;
        default:
            break;
        }
}
// Handler for timer3
void Timer3IntHandler(void) {
    // SW interrupt to stop the program
    if (stop)
    {
        ROM_TimerDisable(TIMER4_BASE, TIMER_A);
    }

    ROM_TimerIntClear(TIMER3_BASE, TIMER_TIMA_TIMEOUT);
    //UARTprintf("Inside Timer 2\n\n\n\n\n\n");
    //ROM_TimerLoadSet(TIMER2_BASE, TIMER_A, (ROM_SysCtlClockGet()-1));
    uint32_t result;
        switch(stim_state[2]){
        case 0:
            //toggle stimulation polarity to negative
            //clear bit in sti_command_lower
            result = my_read_register(44);
            result = (result & ~sti_channel_masks_arr[2]);
            sti_command_lower = result;
            sti_command_upper = 0b1010000000101100;
            SPI_Send(sti_command_upper, sti_command_lower);
            while(ROM_SSIDataGetNonBlocking(SSI0_BASE, &pui32DataRx[0]))
            {
            }
            // turn on stimulator
            //set bits in sti_command_lower
            result = my_read_register(42);
            result = (result | sti_channel_masks_arr[2]);
            //uint32_t channels_command = (1 << sti_channel[0])| (1 << sti_channel[1]);
            sti_command_lower = result;
            sti_command_upper = 0b1010000000101010;
            SPI_Send(sti_command_upper, sti_command_lower);
            while(ROM_SSIDataGetNonBlocking(SSI0_BASE, &pui32DataRx[0]))
            {
            }
           // int pos_pulse_width = pos_pulse_width_temp;
            //UARTprintf("pos_pulse_width = %d\n\n",pos_pulse_width);
            ROM_TimerLoadSet(TIMER3_BASE, TIMER_A, (ROM_SysCtlClockGet()/1000000)*neg_pulse_width[2]-1);
            stim_state[2]++;
            break;
        case 1:
            // toggle stimulation polarity to positive
            //set bits in sti_command_lower
            result = my_read_register(44);
            result = (result | sti_channel_masks_arr[2]);
            sti_command_lower = result;
            sti_command_upper = 0b1010000000101100;
            SPI_Send(sti_command_upper, sti_command_lower);
            while(ROM_SSIDataGetNonBlocking(SSI0_BASE, &pui32DataRx[0]))
            {
            }
            ROM_TimerLoadSet(TIMER3_BASE, TIMER_A, (ROM_SysCtlClockGet()/1000000)*pos_pulse_width[2]-1);
            stim_state[2]++;
            break;
        case 2 :
            // turn off stimulator
            // clear bits in sti_command_lower
            result = my_read_register(42);
            result = (result & ~sti_channel_masks_arr[2]);
            sti_command_lower = result;
            sti_command_upper = 0b1010000000101010;
            SPI_Send(sti_command_upper, sti_command_lower);
            while(ROM_SSIDataGetNonBlocking(SSI0_BASE, &pui32DataRx[0]))
            {
            }
            ROM_TimerLoadSet(TIMER3_BASE, TIMER_A, (ROM_SysCtlClockGet()/1000000)*stim_off_time[2]-1);
            stim_state[2] = 0;
            break;
        default:
            break;
        }
}
// Handler for timer4
void Timer4IntHandler(void) {
    // SW interrupt to stop the program
    if (stop)
    {
        ROM_TimerDisable(TIMER4_BASE, TIMER_A);
    }

    ROM_TimerIntClear(TIMER4_BASE, TIMER_TIMA_TIMEOUT);
    //UARTprintf("Inside Timer 2\n\n\n\n\n\n");
    //ROM_TimerLoadSet(TIMER2_BASE, TIMER_A, (ROM_SysCtlClockGet()-1));
    uint32_t result;
        switch(stim_state[3]){
        case 0:
            //toggle stimulation polarity to negative
            //clear bit in sti_command_lower
            result = my_read_register(44);
            result = (result & ~sti_channel_masks_arr[3]);
            sti_command_lower = result;
            sti_command_upper = 0b1010000000101100;
            SPI_Send(sti_command_upper, sti_command_lower);
            while(ROM_SSIDataGetNonBlocking(SSI0_BASE, &pui32DataRx[0]))
            {
            }
            // turn on stimulator
            //set bits in sti_command_lower
            result = my_read_register(42);
            result = (result | sti_channel_masks_arr[3]);
            //uint32_t channels_command = (1 << sti_channel[0])| (1 << sti_channel[1]);
            sti_command_lower = result;
            sti_command_upper = 0b1010000000101010;
            SPI_Send(sti_command_upper, sti_command_lower);
            while(ROM_SSIDataGetNonBlocking(SSI0_BASE, &pui32DataRx[0]))
            {
            }
           // int pos_pulse_width = pos_pulse_width_temp;
            //UARTprintf("pos_pulse_width = %d\n\n",pos_pulse_width);
            ROM_TimerLoadSet(TIMER4_BASE, TIMER_A, (ROM_SysCtlClockGet()/1000000)*neg_pulse_width[3]-1);
            stim_state[3]++;
            break;
        case 1:
            // toggle stimulation polarity to positive
            //set bits in sti_command_lower
            result = my_read_register(44);
            result = (result | sti_channel_masks_arr[3]);
            sti_command_lower = result;
            sti_command_upper = 0b1010000000101100;
            SPI_Send(sti_command_upper, sti_command_lower);
            while(ROM_SSIDataGetNonBlocking(SSI0_BASE, &pui32DataRx[0]))
            {
            }
            ROM_TimerLoadSet(TIMER4_BASE, TIMER_A, (ROM_SysCtlClockGet()/1000000)*pos_pulse_width[3]-1);
            stim_state[3]++;
            break;
        case 2 :
            // turn off stimulator
            // clear bits in sti_command_lower
            result = my_read_register(42);
            result = (result & ~sti_channel_masks_arr[3]);
            sti_command_lower = result;
            sti_command_upper = 0b1010000000101010;
            SPI_Send(sti_command_upper, sti_command_lower);
            while(ROM_SSIDataGetNonBlocking(SSI0_BASE, &pui32DataRx[0]))
            {
            }
            ROM_TimerLoadSet(TIMER4_BASE, TIMER_A, (ROM_SysCtlClockGet()/1000000)*stim_off_time[3]-1);
            stim_state[3] = 0;
            break;
        default:
            break;
        }
}

// Timer5 Handler for storing ICM gyro and accel readings to buffer
void Timer5IntHandler(void)
{
    // Buffer count
    static int count = 0;
    int len;
    static int sample_num = 0;

    // Clear the timer interrupt. Recommended to do so earilest as possible.
    ROM_TimerIntClear(TIMER5_BASE, TIMER_TIMA_TIMEOUT);

    // SW interrupt to stop the program
    if (stop)
    {
        ROM_TimerDisable(TIMER5_BASE, TIMER_A);
    }

    // Read gyro and accel axises
    icm20948_gyro_read_dps(&gyro_axises);
    icm20948_accel_read_g(&accel_axises);

//    UARTprintfICM(accel_axises, gyro_axises);

    // could be sampling and storing together in timer5_int at lower freq
//    ICM_bufferA[count++] = (uint16_t) accel_axises.x + 1;
//    ICM_bufferA[count++] = (uint16_t) accel_axises.y + 1;
//    ICM_bufferA[count++] = (uint16_t) accel_axises.z + 1;
//    ICM_bufferA[count++] = (uint16_t) gyro_axises.x + 1;
//    ICM_bufferA[count++] = (uint16_t) gyro_axises.y + 1;
//    ICM_bufferA[count++] = (uint16_t) gyro_axises.z + 1;
//    sample_num++;
//    // Store the buffer every 1 sec
//    if(count == 6 * ICM_sampling_frequency)
//    {
//        len = uint16_len(ICM_bufferA);
//        count = 0;
//        rc = f_write(&fil_icm, ICM_bufferA, len * 2, &bw);
//        if(rc != FR_OK)
//        {
//#ifdef DEBUG
//            UARTprintf("ICM Cannot write to file! Bye!\n");
//#endif
//           return 0;
//        }
//        else
//        {
//           // ROM_GPIOPinWrite(GPIO_PORTA_BASE, LED_G, LED_G);
//#ifdef DEBUG
//            UARTprintf("Sample No.%d wrote %d data from ICM_bufferA to SD card\n", sample_num, len);
//#endif
//        }
//
////        UARTprintf("NOW Count: %d ICM_bufferA size: %d\n ", count, len);
////        int i = 0;
////        for (i = 0; i < len; i++)
////        {
////            UARTprintf("%d\t",ICM_bufferA[i]);
////        }
//    }
    if(ICM_bufferA_empty || ICM_bufferB_empty) { // check if any buffer is empty or has space
//           if(ICM_buffer_mode == ICM_BUFFER_A) {
//               ICM_bufferA[count++] = (uint16_t) accel_axises.x + 1;
//               ICM_bufferA[count++] = (uint16_t) accel_axises.y + 1;
//               ICM_bufferA[count++] = (uint16_t) accel_axises.z + 1;
//               ICM_bufferA[count++] = (uint16_t) gyro_axises.x + 1;
//               ICM_bufferA[count++] = (uint16_t) gyro_axises.y + 1;
//               ICM_bufferA[count++] = (uint16_t) gyro_axises.z + 1;
//               ICM_sample_num++;
//           }
//           else if(ICM_buffer_mode == ICM_BUFFER_B) {
//               ICM_bufferB[count++] = (uint16_t) accel_axises.x + 1;
//               ICM_bufferB[count++] = (uint16_t) accel_axises.y + 1;
//               ICM_bufferB[count++] = (uint16_t) accel_axises.z + 1;
//               ICM_bufferB[count++] = (uint16_t) gyro_axises.x + 1;
//               ICM_bufferB[count++] = (uint16_t) gyro_axises.y + 1;
//               ICM_bufferB[count++] = (uint16_t) gyro_axises.z + 1;
//               ICM_sample_num++;
//           }
           if(ICM_buffer_mode == ICM_BUFFER_A) {
                  ICM_bufferA[count++] = (uint16_t) 1;
                  ICM_bufferA[count++] = (uint16_t) 2;
                  ICM_bufferA[count++] = (uint16_t) 3;
                  ICM_bufferA[count++] = (uint16_t) 4;
                  ICM_bufferA[count++] = (uint16_t) 5;
                  ICM_bufferA[count++] = (uint16_t) 6;
                  ICM_sample_num++;
              }
              else if(ICM_buffer_mode == ICM_BUFFER_B) {
                  ICM_bufferB[count++] = (uint16_t) 9;
                  ICM_bufferB[count++] = (uint16_t) 9;
                  ICM_bufferB[count++] = (uint16_t) 0;
                  ICM_bufferB[count++] = (uint16_t) 5;
                  ICM_bufferB[count++] = (uint16_t) 0;
                  ICM_bufferB[count++] = (uint16_t) 6;
                  ICM_sample_num++;
              }
           if(count >= ICM_buffer_size - 12) { // check if count equals buffer_size, or if the buffer is full
               ICM_buffer_len = count;
               count = 0;
               // switch buffer mode and enable storage on SD card
               if(ICM_buffer_mode == ICM_BUFFER_A)
               {
                   UARTprintf("Now in mode ICM_BUFFER_A. Change to ICM_BUFFER_B\n");
                   ICM_buffer_mode = ICM_BUFFER_B;
                   ICM_bufferA_empty = false;
                   ICM_storage_on = true;
               }
               else if(ICM_buffer_mode == ICM_BUFFER_B) {
                   UARTprintf("Now in mode ICM_BUFFER_B. Change to ICM_BUFFER_A\n");
                   ICM_buffer_mode = ICM_BUFFER_A;
                   ICM_bufferB_empty = false;
                   ICM_storage_on = true;
               }
           }
       }



}

/* ------------------------------------          Main        ---------------------------------- */
// main function
int main(void)
{
    uint32_t ret;
    int j;

    // ICM sampling frequency
    ICM_sampling_frequency = ICM_SAMPLING_FREQUENCY;
    ICM_buffer_len = 0;
    ICM_sample_num = 0;
    int ICM_file_len = 0;

    // buffer for read data from SD Card
    TCHAR read_buffer[32];
    TCHAR *command;
    TCHAR *value;
    TCHAR *channel_value;

    //add for stimulation chan
//    TCHAR *sti_channel_value;

    dummy = 0;
    count = 0;
    // counter for loops when writing to SD card
    uint32_t store_count;
    uint32_t i = 0;

    // data read from SD card for configuration
    uint32_t read_value;
    uint32_t sampling_frequency;
    uint32_t sampling_frequency_total;
    uint32_t file_seconds;

    uint32_t cutoff_upper;
    uint32_t cutoff_lower;

    //variables to track stimulation data for multiple channels
    uint32_t pos_pulse_width_temp[16];   //in uA
    uint32_t neg_pulse_width_temp[16];   //in uA
    uint32_t stim_period_temp[16];       //in uA
    //Note: treat this as an array of booleans (doesn't work with volatile bool ...)
    uint32_t stim_on[16];/* = {[0 ... 15] = 0}*/

    int pos_pulse_magnitude[16];
    int neg_pulse_magnitude[16];
    int cur_channel = 0;

    char def_filename[16];
    char filename[16];

    // counter for current file
    uint32_t file_counter = 0;
    int RHS_file_len = 0;

    channel_number = 0;
    sti_channel_number = 0;

    ROM_SysCtlClockSet(SYSCTL_SYSDIV_4 | SYSCTL_USE_PLL | SYSCTL_OSC_INT | SYSCTL_MAIN_OSC_DIS); // 50MHz System Clock

#ifdef DEBUG
    uart_init();
#endif

#ifdef DEBUG
    UARTprintf("OK, let's begin!\n");
#endif

    // initialize channel[32];
    for (j=0; j<=32; j++){
        channel[j] = 33;
    }
    // initialize sti_channel[32];
    for (j=0; j<=32; j++){
        sti_channel[j] = 33;
    }

    /***********************************************************/
    /* SD Card configuration */
    /***********************************************************/
    // configure the systick timer for a 100Hz interrupt. required by the FatFs driver.
    ROM_SysTickPeriodSet(ROM_SysCtlClockGet() / 100);
    SysTickIntRegister(SysTickHandler);
    ROM_SysTickEnable();
    ROM_SysTickIntEnable();

    // Delay a little for SD card to initialise
    ROM_SysCtlDelay(ROM_SysCtlClockGet()/3);

    ROM_GPIOPinTypeGPIOOutput(GPIO_PORTA_BASE, LED_R | LED_G);
    ROM_GPIOPinWrite(GPIO_PORTA_BASE, LED_R, LED_R);
    ROM_GPIOPinWrite(GPIO_PORTA_BASE, LED_G, LED_G);

    // mount the SD Card using logical drive 0.
    rc = f_mount(0, &fatfs);

    if(rc != FR_OK)
    {
#ifdef DEBUG
        UARTprintf("f_mount error\n");
#endif
        return 0;
    }
    else
    {
#ifdef DEBUG
        UARTprintf("f_mount success!\n");
#endif
    }

    /***********************************************************/
    /* get device configuration from SD card*/
    /***********************************************************/
    // open the configuration file
    rc = f_open(&fil, "confighd.txt", FA_READ);
    if(rc != FR_OK)
    {
#ifdef DEBUG
        UARTprintf("Configuration file doesn't exist. Bye!\n");
#endif
        return 0;
    }
    else
    {
#ifdef DEBUG
        UARTprintf("Configuration file found!\n");
#endif
        // get configuration parameters
        // about f_eof:  #define f_eof(fp) (((fp)->fptr == (fp)->fsize) ? 1 : 0)
        //&fil is the pointer to the current position?
        while(!f_eof(&fil)) {
            f_gets((char *)read_buffer, sizeof(read_buffer), &fil);
            command = strtok(read_buffer, ":"); //strtok function breaks string into a series of tokens using a delimiter
            value = strtok(NULL, ":");
            if(strcmp(command, "sampling_frequency") == 0) {
                read_value = strtol(value, NULL,10); //strtol function converts string to integer
#ifdef DEBUG
                UARTprintf("sampling_frequency:%d\n", read_value);
#endif
                sampling_frequency = read_value;
            }
            else if(strcmp(command, "buffer_size") == 0) {
                read_value = strtol(value, NULL,10);
#ifdef DEBUG
                UARTprintf("buffer_size:%d\n", read_value);
#endif
                RHS_buffer_size = read_value; // this value is number of bytes (8-bit)
                RHS_buffer_size = RHS_buffer_size/2; // as we are using 16-bit data, we divide by two;
#ifdef DEBUG
                UARTprintf("adjusted RHS_buffer_size:%d\n", RHS_buffer_size);
#endif
            }
            else if(strcmp(command, "file_seconds") == 0) {
                read_value = strtol(value, NULL,10);
#ifdef DEBUG
                UARTprintf("file_seconds:%d\n", read_value);
#endif
                file_seconds = read_value;
            }
            else if(strcmp(command, "filename") == 0) {
                value[strlen(value)-2] = '\0';
#ifdef DEBUG
                UARTprintf("length of filename:%d\n", strlen(value));
#endif
                strcpy(def_filename, value);
#ifdef DEBUG
                UARTprintf("filename:%s\n", def_filename);
#endif
            }
            else if(strcmp(command, "cutoff_upper") == 0) {
                read_value = strtol(value, NULL,10);
#ifdef DEBUG
                UARTprintf("cutoff_upper:%d\n", read_value);
#endif
                cutoff_upper = read_value;
            }
            else if(strcmp(command, "cutoff_lower") == 0) {
                read_value = strtol(value, NULL,10);
#ifdef DEBUG
                UARTprintf("cutoff_lower:%d\n", read_value);
#endif
                cutoff_lower = read_value;
            }
            else if(strcmp(command, "channel") == 0) {
                // value: 1,2,3,4 break it into single integers
                channel_value = strtok(value, ",");
                j = 0;
                while(channel_value != NULL)
                {
                    channel[j] = strtol(channel_value, NULL, 10);
                    j += 1;

                    channel_value = strtok(NULL, ",");
                }
                j = 0;
#ifdef DEBUG
                while(channel[j] != 33)
                {
                    UARTprintf("Sampling_channel:%d\n", channel[j]);
                    j += 1;
                }
#endif
            }
            //***********Stimulator 0 ***********//
            else if(strcmp(command, "stimulator0_") == 0) {
                if(strncmp(value, "on",2) == 0){
                    stim_on[cur_channel] = 1;
#ifdef DEBUG
                    UARTprintf("Stimulator is on\n");
#endif
                }else{
                    stim_on[cur_channel] = 0;
#ifdef DEBUG
                    UARTprintf("Stimulator is off\n");
#endif
                }
            }
            else if(strcmp(command, "sti_channel0_") == 0) {
                // value: 1,2,3,4 break it into single integers
                read_value = strtol(value, NULL,10);
                sti_channel[cur_channel] = read_value;
            }
            else if(strcmp(command, "stim_period0(us)") == 0) {
                read_value = strtol(value, NULL,10);

#ifdef DEBUG
                UARTprintf("Stimulation_period:%d\n", read_value);
#endif
                stim_period_temp[cur_channel] = read_value;
            }
            else if(strcmp(command, "pos_pulse_magnitude0(nA)") == 0) {
                read_value = strtol(value, NULL,10);
#ifdef DEBUG
                UARTprintf("Positive_pulse_width:%d\n", read_value);
#endif
                pos_pulse_magnitude[cur_channel] = read_value;
            }
            else if(strcmp(command, "pos_pulse_width0(us)") == 0) {
                read_value = strtol(value, NULL,10);
#ifdef DEBUG
                UARTprintf("Positive_pulse_width:%d\n", read_value);
#endif
                pos_pulse_width_temp[cur_channel] = read_value;
            }
            else if(strcmp(command, "neg_pulse_magnitude0(nA)") == 0) {
                read_value = strtol(value, NULL,10);
#ifdef DEBUG
                UARTprintf("Positive_pulse_width:%d\n", read_value);
#endif
                neg_pulse_magnitude[cur_channel] = read_value;
            }
            else if(strcmp(command, "neg_pulse_width0(us)") == 0) {
                read_value = strtol(value, NULL,10);
#ifdef DEBUG
                UARTprintf("Negative_pulse_width:%d\n", read_value);
#endif
                neg_pulse_width_temp[cur_channel] = read_value;
                //update the current channel count for the next channel
                cur_channel++;
            }
            //***********Stimulator 1 ***********//
            else if(strcmp(command, "stimulator1_") == 0) {
                if(strncmp(value, "on",2) == 0){
                    stim_on[cur_channel] = 1;
#ifdef DEBUG
                    UARTprintf("Stimulator is on\n");
#endif
                }else{
                    stim_on[cur_channel] = 0;
#ifdef DEBUG
                    UARTprintf("Stimulator is off\n");
#endif
                }
            }
            else if(strcmp(command, "sti_channel1_") == 0) {
                // value: 1,2,3,4 break it into single integers
                read_value = strtol(value, NULL,10);
                sti_channel[cur_channel] = read_value;
            }
            else if(strcmp(command, "stim_period1(us)") == 0) {
                read_value = strtol(value, NULL,10);

#ifdef DEBUG
                UARTprintf("Stimulation_period:%d\n", read_value);
#endif
                stim_period_temp[cur_channel] = read_value;
            }
            else if(strcmp(command, "pos_pulse_magnitude1(nA)") == 0) {
                read_value = strtol(value, NULL,10);
#ifdef DEBUG
                UARTprintf("Positive_pulse_width:%d\n", read_value);
#endif
                pos_pulse_magnitude[cur_channel] = read_value;
            }
            else if(strcmp(command, "pos_pulse_width1(us)") == 0) {
                read_value = strtol(value, NULL,10);
#ifdef DEBUG
                UARTprintf("Positive_pulse_width:%d\n", read_value);
#endif
                pos_pulse_width_temp[cur_channel] = read_value;
            }
            else if(strcmp(command, "neg_pulse_magnitude1(nA)") == 0) {
                read_value = strtol(value, NULL,10);
#ifdef DEBUG
                UARTprintf("Positive_pulse_width:%d\n", read_value);
#endif
                neg_pulse_magnitude[cur_channel] = read_value;
            }
            else if(strcmp(command, "neg_pulse_width1(us)") == 0) {
                read_value = strtol(value, NULL,10);
#ifdef DEBUG
                UARTprintf("Negative_pulse_width:%d\n", read_value);
#endif
                neg_pulse_width_temp[cur_channel] = read_value;
                //update the current channel count for the next channel
                cur_channel++;
            }

            //***********Stimulator 2 ***********//
            else if(strcmp(command, "stimulator2_") == 0) {
                if(strncmp(value, "on",2) == 0){
                    stim_on[cur_channel] = 1;
#ifdef DEBUG
                    UARTprintf("Stimulator is on\n");
#endif
                }else{
                    stim_on[cur_channel] = 0;
#ifdef DEBUG
                    UARTprintf("Stimulator is off\n");
#endif
                }
            }
            else if(strcmp(command, "sti_channel2_") == 0) {
                // value: 1,2,3,4 break it into single integers
                read_value = strtol(value, NULL,10);
                sti_channel[cur_channel] = read_value;
            }
            else if(strcmp(command, "stim_period2(us)") == 0) {
                read_value = strtol(value, NULL,10);

#ifdef DEBUG
                UARTprintf("Stimulation_period:%d\n", read_value);
#endif
                stim_period_temp[cur_channel] = read_value;
            }
            else if(strcmp(command, "pos_pulse_magnitude2(nA)") == 0) {
                read_value = strtol(value, NULL,10);
#ifdef DEBUG
                UARTprintf("Positive_pulse_width:%d\n", read_value);
#endif
                pos_pulse_magnitude[cur_channel] = read_value;
            }
            else if(strcmp(command, "pos_pulse_width2(us)") == 0) {
                read_value = strtol(value, NULL,10);
#ifdef DEBUG
                UARTprintf("Positive_pulse_width:%d\n", read_value);
#endif
                pos_pulse_width_temp[cur_channel] = read_value;
            }
            else if(strcmp(command, "neg_pulse_magnitude2(nA)") == 0) {
                read_value = strtol(value, NULL,10);
#ifdef DEBUG
                UARTprintf("Positive_pulse_width:%d\n", read_value);
#endif
                neg_pulse_magnitude[cur_channel] = read_value;
            }
            else if(strcmp(command, "neg_pulse_width2(us)") == 0) {
                read_value = strtol(value, NULL,10);
#ifdef DEBUG
                UARTprintf("Negative_pulse_width:%d\n", read_value);
#endif
                neg_pulse_width_temp[cur_channel] = read_value;
                //update the current channel count for the next channel
                cur_channel++;
            }
            //***********Stimulator 3 ***********//
            else if(strcmp(command, "stimulator3_") == 0) {
                if(strncmp(value, "on",2) == 0){
                    stim_on[cur_channel] = 1;
#ifdef DEBUG
                    UARTprintf("Stimulator is on\n");
#endif
                }else{
                    stim_on[cur_channel] = 0;
#ifdef DEBUG
                    UARTprintf("Stimulator is off\n");
#endif
                }
            }
            else if(strcmp(command, "sti_channel3_") == 0) {
                // value: 1,2,3,4 break it into single integers
                read_value = strtol(value, NULL,10);
                sti_channel[cur_channel] = read_value;
            }
            else if(strcmp(command, "stim_period3(us)") == 0) {
                read_value = strtol(value, NULL,10);

#ifdef DEBUG
                UARTprintf("Stimulation_period:%d\n", read_value);
#endif
                stim_period_temp[cur_channel] = read_value;
            }
            else if(strcmp(command, "pos_pulse_magnitude3(nA)") == 0) {
                read_value = strtol(value, NULL,10);
#ifdef DEBUG
                UARTprintf("Positive_pulse_width:%d\n", read_value);
#endif
                pos_pulse_magnitude[cur_channel] = read_value;
            }
            else if(strcmp(command, "pos_pulse_width3(us)") == 0) {
                read_value = strtol(value, NULL,10);
#ifdef DEBUG
                UARTprintf("Positive_pulse_width:%d\n", read_value);
#endif
                pos_pulse_width_temp[cur_channel] = read_value;
            }
            else if(strcmp(command, "neg_pulse_magnitude3(nA)") == 0) {
                read_value = strtol(value, NULL,10);
#ifdef DEBUG
                UARTprintf("Positive_pulse_width:%d\n", read_value);
#endif
                neg_pulse_magnitude[cur_channel] = read_value;
            }
            else if(strcmp(command, "neg_pulse_width3(us)") == 0) {
                read_value = strtol(value, NULL,10);
#ifdef DEBUG
                UARTprintf("Negative_pulse_width:%d\n", read_value);
#endif
                neg_pulse_width_temp[cur_channel] = read_value;
                //update the current channel count for the next channel
                cur_channel++;
            }
            else {
#ifdef DEBUG
                UARTprintf("wrong command\n");
#endif
            }
        }
        f_close(&fil);
    }
    //SET THE CHANNELS HERE BECAUSE READING FROM FILE IS FAILING
//    int k;
//    for(k = 0; k < 4; k++){
//            channel[k] = k;
//    }
//    for(k = 4; k < 16; k++){
//            channel[k] = k;
//    }
    /***********************************************************/
    /* set device configuration*/
    /***********************************************************/
    // set current filename in use
    sprintf(filename, "%s%d.txt", def_filename, file_counter);

    // set up buffers
    RHS_bufferA = (uint16_t *)malloc(RHS_buffer_size*sizeof(uint16_t));
    RHS_bufferB = (uint16_t *)malloc(RHS_buffer_size*sizeof(uint16_t));

    // TODO: Read ICM_buffer_size from confighd.txt
    ICM_buffer_size = 1024;
    ICM_bufferA = (uint16_t *)calloc(ICM_buffer_size, sizeof(uint16_t));
    ICM_bufferB = (uint16_t *)calloc(ICM_buffer_size, sizeof(uint16_t));
    // initial icm config
    ICM_buffer_mode = ICM_BUFFER_A; // first start from buffer A
    ICM_storage_on = false; // currently write to SD card is disabled
    ICM_bufferA_empty = true; // buffer is empty
    ICM_bufferB_empty = true;   // buffer is empty

    // initial config
    RHS_buffer_mode = RHS_BUFFER_A; // first start from buffer A
    RHS_storage_on = false; // currently write to SD card is disabled
    RHS_bufferA_empty = true; // buffer is empty
    RHS_bufferB_empty = true;   // buffer is empty

    // calculate the required total sampling frequency
    j = 0;
    while (channel[j] != 33)
    {
        channel_number += 1;
        j += 1;
    }
    //get channel_number for stimulation channel
    j = 0;
    while (sti_channel[j] != 33)
    {
        sti_channel_number += 1;
        j += 1;
    }
#ifdef DEBUG
    UARTprintf("Number of stimulation channels:%d\n", sti_channel_number);
#endif
#ifdef DEBUG
    UARTprintf("Total channel number:%d\n", channel_number);
#endif

    sampling_frequency_total = channel_number * sampling_frequency;
#ifdef DEBUG
    UARTprintf("Total sampling frequency:%d\n", sampling_frequency_total);
#endif

    // number of times complete buffer should be written to the SD card
    // to match the duration specified by file_minutes and
    // using 16-bit data (12-bit ADC resolution)
    store_count = (file_seconds * sampling_frequency_total) / RHS_buffer_size;
#ifdef DEBUG
    UARTprintf("Store count in each file: %d\n", store_count);
#endif

    // ICM SPI init
    ICM_SPI_init();

    // Headstage SPI init
    SPIInit();
    ROM_SysCtlDelay(SysCtlClockGet()/3);


    /***********************************************************/
    /* Initialize the headstage */
    /***********************************************************/

    if(headstage_init() == 0){
#ifdef DEBUG
        UARTprintf("Headstage cannot be initialized. Bye!\n");
#endif
        // return 0;
    }else{
#ifdef DEBUG
        UARTprintf("Headstage successfully initialized!\n");
#endif
    }

    /***********************************************************/
    /* Check the register values */
    /***********************************************************/
    if(headstage_init_check() == 1){
#ifdef DEBUG
        UARTprintf("Register values checked!\n");
#endif
    }else{
#ifdef DEBUG
        UARTprintf("Register values are not as expected. Bye!\n");
#endif
        // return 0;
    }

    /***********************************************************/
    /* Check the register 1 specifically */
    /***********************************************************/
    if(read_check(1, 0x051A) == 1){
#ifdef DEBUG
        UARTprintf("Register 1 checked!\n");
#endif
    }else{
#ifdef DEBUG
        UARTprintf("Register 1 value is not as expected, it's:\n");
        read_register(1);
#endif
        // return 0;
    }

    // re-write the register 0, according to the desired sampling rate
    Frequency_set(sampling_frequency_total);
    // check register 0 value
    if(register0_check(sampling_frequency_total) == 1){
#ifdef DEBUG
        UARTprintf("Register 0 value checked!\n");
#endif
    }else{
#ifdef DEBUG
        UARTprintf("Register 0 value is not as expected, it's:\n");
        read_register(0);
#endif
        // return 0;
    }

    // re-write register 4,5,6
    if (Bandwidth_set(cutoff_upper, cutoff_lower) == 1){
#ifdef DEBUG
        UARTprintf("Bandwidth set!\n");
#endif
    }else{
        UARTprintf("Unable to set bandwidth!\n");
    }

    if (register4_check(cutoff_upper) == 1){
#ifdef DEBUG
        UARTprintf("Register 4 checked!\n");
#endif
    }else{
#ifdef DEBUG
        UARTprintf("Unable to set register 4, bye!\n");
#endif
        // return 0;
    }

    if (register5_check(cutoff_upper) == 1){
#ifdef DEBUG
        UARTprintf("Register 5 checked!\n");
#endif
    }else{
#ifdef DEBUG
        UARTprintf("Unable to set register 5, bye!\n");
#endif
        // return 0;
    }

    if (register6_check(cutoff_lower) == 1){
#ifdef DEBUG
        UARTprintf("Register 6 checked!\n");
#endif
    }else{
#ifdef DEBUG
        UARTprintf("Unable to set register 6, bye!\n");
#endif
        // return 0;
    }


    //**********************************************************/
    /* Initialize the Stimulator */
    //**********************************************************/

    // set magnitude
    // positive stimulation, register 96-111
    //step_val = sti_magnitude/step_size;

    //initialize all stimulation channels
    int k = 0;
    for(k = 0; k < sti_channel_number; k++){
        SPI_Send((0b1010000000000000 + 96 + sti_channel[k]), (0b1000000000000000 + (pos_pulse_magnitude[k]/10000)));
        while(ROM_SSIDataGetNonBlocking(SSI0_BASE, &pui32DataRx[0]))
        {
        }
        // negative stimulation, register 64-79
        //step_val = sti_magnitude/step_size;
        SPI_Send((0b1010000000000000 + 64 + sti_channel[k]), (0b1000000000000000 + (neg_pulse_magnitude[k]/10000)));
        while(ROM_SSIDataGetNonBlocking(SSI0_BASE, &pui32DataRx[0]))
        {
        }
    }
    // re-write register 32 and 33, enable stimulator
    SPI_Send(0b1011000000100000, 0xAAAA); // M = 1, U = 1
    while(ROM_SSIDataGetNonBlocking(SSI0_BASE, &pui32DataRx[0]))
    {
    }
    SPI_Send(0b1010000000100001, 0x00FF);
    while(ROM_SSIDataGetNonBlocking(SSI0_BASE, &pui32DataRx[0]))
    {
    }

    // re-write register 42, ensure all the stimulators are off
    SPI_Send(0b1011000000101010, 0);
    while(ROM_SSIDataGetNonBlocking(SSI0_BASE, &pui32DataRx[0]))
    {
    }

    //update the global variables here (note that we need to do this for the code to work)
    //Note: this only works at this location! don't try moving it anywhere else
    k = 0;
    for(k = 0; k < sti_channel_number; k++){
        pos_pulse_width[k]= pos_pulse_width_temp[k];
        //UARTprintf("pos_pulse_width:%d\n", pos_pulse_width[k]);
        neg_pulse_width[k]= neg_pulse_width_temp[k];
        //UARTprintf("neg_pulse_width:%d\n", neg_pulse_width[k]);
        stim_period[k] = stim_period_temp[k];
        //UARTprintf("stim_period:%d\n", stim_period[k]);
        //calculate the stimulation off duration
        stim_off_time[k] = stim_period[k] - (pos_pulse_width[k] + neg_pulse_width[k]);
    }

    //initilize the channel_masks array
    k = 0;
    for(k = 0; k < sti_channel_number; k++){
        sti_channel_masks_arr[k] = 1 << sti_channel[k];
    }
    //UARTprintf("delay\n");
    k = 0;
    for(k = 0; k < sti_channel_number; k++){
        sti_channel_all_mask = (sti_channel_all_mask | 1 << sti_channel[k]);
    }
//    // turn on stimulator for each channel
//        //sti_command_lower = 1<<sti_channel[k];
//        sti_command_lower = sti_channel_all_mask;
//        sti_command_upper = 0b1010000000101010;
//        //timer1_state += 1;
//        // send the command
//        SPI_Send(sti_command_upper, sti_command_lower);
//        while(ROM_SSIDataGetNonBlocking(SSI0_BASE, &pui32DataRx))
//        {
//        }
    //    UARTprintf("another delay\n");

    /***********************************************************/
    /* Enable global interrupt */
    /***********************************************************/
    ROM_IntMasterEnable();

    timer0_init(sampling_frequency_total);

    timer1_init();
    timer2_init();
    timer3_init();
    timer4_init();

    //turn on corresponding stimulators
    if(stim_on[0]){
        ROM_TimerEnable(TIMER1_BASE, TIMER_A);
    }
    if(stim_on[1]){
        ROM_TimerEnable(TIMER2_BASE, TIMER_A);
    }
    if(stim_on[2]){
        ROM_TimerEnable(TIMER3_BASE, TIMER_A);
    }
    if(stim_on[3]){
        ROM_TimerEnable(TIMER4_BASE, TIMER_A);
    }
    //Timer 1 load
    ROM_TimerLoadSet(TIMER1_BASE, TIMER_A, (ROM_SysCtlClockGet()/10000-1));
    //Timer 2 load
    ROM_TimerLoadSet(TIMER2_BASE, TIMER_A, (ROM_SysCtlClockGet()/10000-1));
    //Timer 3 load
    ROM_TimerLoadSet(TIMER3_BASE, TIMER_A, (ROM_SysCtlClockGet()/10000-1));
    //Timer 4 load
    ROM_TimerLoadSet(TIMER4_BASE, TIMER_A, (ROM_SysCtlClockGet()/10000-1));

    /* ------------------------------------          Pushbuhtton init        ---------------------------------- */
    SW_int_init();

    /* ------------------------------------          Accel and Gyro init        ---------------------------------- */
    ret = ICM_SPI_Read(0x00);
    UARTprintf("ICM20948 is 0xea ? -> 0x%x\n", ret);
    icm20948_init();
    ROM_SysCtlDelay(SysCtlClockGet()/3);
    UARTprintf("Init check done. Start Reading ...\n");

    timer5_init(ICM_sampling_frequency);


    /***********************************************************/
    /* Open first file to write */
    /***********************************************************/
    rc = f_open(&fil, filename, FA_CREATE_ALWAYS );
    if(rc != FR_OK)
    {
#ifdef DEBUG
        UARTprintf("Cannot open file for writing data. Bye!\n");
#endif
        return 0;
    }
    else
    {
#ifdef DEBUG
        UARTprintf("Now writing to file: %s\n", filename);
#endif
    }

    // Open file for ICM writing
    char ICM_filename[] = "ICM.txt";
    rc = f_open(&fil_icm, ICM_filename, FA_CREATE_ALWAYS );
    if(rc != FR_OK)
    {
    #ifdef DEBUG
            UARTprintf("Cannot FA_CREATE_ALWAYS  %s\n", ICM_filename);
    #endif
            return 0;
        }
        else
        {
    #ifdef DEBUG
            UARTprintf("Success: FA_CREATE_ALWAYS %s\n", ICM_filename);
    #endif
    }
    ROM_SysCtlDelay(ROM_SysCtlClockGet()/3);


    // ROM_GPIOPinWrite(GPIO_PORTA_BASE, LED_R, LED_R); // turn off red LED
    /***********************************************************/
    /* Main application loop */
    /***********************************************************/
    //ROM_TimerLoadSet(TIMER1_BASE, TIMER_A, (ROM_SysCtlClockGet()/100-1));

    while(!stop){
        /* ------------------------------------         Headstage storage        ---------------------------------- */
        if(RHS_storage_on) { // check if write to SD card is enabled

            // check if storecount for the file matches store-count.
            // if it matches, we must close this file and create a new file for writing to
            // ROM_GPIOPinWrite(GPIO_PORTA_BASE, LED_G, LED_G);
            if(i == store_count) {
                f_close(&fil); // close the open file
                file_counter = file_counter + 1; // increment the counter
                i = 0;
                sprintf(filename, "%s%d.txt", def_filename, file_counter); // generate new filename

                rc = f_open(&fil, filename, FA_CREATE_ALWAYS ); // open the new file
                if(rc != FR_OK)
                {
#ifdef DEBUG
                    UARTprintf("Cannot open file for writing data. Bye!\n");
#endif
                    return 0;
                }
                else
                {
#ifdef DEBUG
                    UARTprintf("Now writing to RHS_file: %s\n", filename);
                    f_close(&fil); // close the open file
#endif
                }
            }else{
                //do nothing
            }

            rc = f_open(&fil, filename, FA_OPEN_EXISTING | FA_WRITE);
            if(rc != FR_OK)
            {
#ifdef DEBUG
                UARTprintf("Cannot FA_OPEN_EXISTING | FA_WRITE RHS_file for writing data. Bye!\n");
#endif
                return 0;
            }
            else
            {
#ifdef DEBUG
                UARTprintf("Now writing to RHS_file: %s\n", filename);
#endif
            }
//            rc = f_lseek(&fil, RHS_file_len);
//            RHS_file_len += RHS_buffer_size * 2;
//            if(rc != FR_OK)
//            {
//                    UARTprintf("Cannot f_lseek %s\n", filename);
//                    return 0;
//            }
//            else
//            {
//                    UARTprintf("Success: f_lseek RHS_file_len = %d\n", RHS_file_len);
//            }

            // ROM_GPIOPinWrite(GPIO_PORTA_BASE, LED_G, 0);
            if(RHS_buffer_mode == RHS_BUFFER_A) { // if A is currently being used, transfer from B
#ifdef DEBUG
                UARTprintf("Now writing RHS_Buffer B\n");
#endif
                // ROM_GPIOPinWrite(GPIO_PORTA_BASE, LED_G, 0);
                rc = f_write(&fil, RHS_bufferB, RHS_buffer_size*2, &bw); // write to SD Card
                if(rc != FR_OK)
                {
#ifdef DEBUG
                    UARTprintf("Cannot write to RHS_file! Bye!\n");
#endif
                    return 0;
                }
                else
                {
                    // ROM_GPIOPinWrite(GPIO_PORTA_BASE, LED_G, LED_G);
#ifdef DEBUG
                    UARTprintf("Wrote RHS_buffer B\n");
#endif
                }
                i = i + 1;
#ifdef DEBUG
                UARTprintf("i: %d\n", i);
#endif
                RHS_bufferB_empty = true;
                RHS_storage_on = false;
            }
            else if(RHS_buffer_mode == RHS_BUFFER_B) { // if B is currently being used, transfer from A.
#ifdef DEBUG
                UARTprintf("Now writing RHS_Buffer A\n");
#endif
                // ROM_GPIOPinWrite(GPIO_PORTA_BASE, LED_G, 0);
                rc = f_write(&fil, RHS_bufferA, RHS_buffer_size*2, &bw); // write to SD Card
                if(rc != FR_OK)
                {
#ifdef DEBUG
                    UARTprintf("Cannot write to RHS_file! Bye!\n");
#endif
                    return 0;
                }
                else
                {
                    // ROM_GPIOPinWrite(GPIO_PORTA_BASE, LED_G, LED_G);
#ifdef DEBUG
                    UARTprintf("Wrote RHS_buffer A\n");
#endif
                }
                i = i + 1;
#ifdef DEBUG
                UARTprintf("i: %d\n", i);
#endif
                RHS_bufferA_empty = true;
                RHS_storage_on = false;
            }
            // ROM_GPIOPinWrite(GPIO_PORTA_BASE, LED_G, LED_G);

            if(dummy == 1000){
                dummy = 0;
            }else{
                dummy += 1;
            }//nonsense, added to make the code work
            f_close(&fil); // close the open file

        }
        else {
            ROM_SysCtlSleep();
        }

        /* ------------------------------------          ICM Storage        ---------------------------------- */
        if(ICM_storage_on)
        {
            rc = f_open(&fil_icm, ICM_filename, FA_OPEN_EXISTING | FA_WRITE);
            if(rc != FR_OK)
            {
                    UARTprintf("Cannot FA_OPEN_EXISTING | FA_WRITE %s\n", ICM_filename);
                    return 0;
            }
            else
            {
                    UARTprintf("Success: FA_OPEN_EXISTING | FA_WRITE %s\n", ICM_filename);
            }
            rc = f_lseek(&fil_icm, ICM_file_len);
            ICM_file_len += ICM_buffer_len * 2;
            if(rc != FR_OK)
            {
                    UARTprintf("Cannot f_lseek %s\n", ICM_filename);
                    return 0;
            }
            else
            {
                    UARTprintf("Success: f_lseek ICM_file_len = %d\n", ICM_file_len);
            }

           if(ICM_buffer_mode == ICM_BUFFER_A) { // if A is currently being used, transfer from B
#ifdef DEBUG
               UARTprintf("Now writing ICM_Buffer B to SD card\n");
#endif

//               ICM_buffer_len = uint16_len(ICM_bufferB);
//               ICM_buffer_len = ICM_buffer_size * 2;
                rc = f_write(&fil_icm, ICM_bufferB, ICM_buffer_len * 2, &bw); // write to SD Card
//                int i = 0;
//               for (i = 0; i < ICM_buffer_len; i++)
//               {
//                   UARTprintf("%d\t",ICM_bufferB[i]);
//               }
               if(rc != FR_OK)
               {
#ifdef DEBUG
                   UARTprintf("Cannot write to ICM_file! Bye!\n");
#endif
                   return 0;
               }
               else
               {
#ifdef DEBUG
                   UARTprintf("Wrote %d ICM data from ICM_buffer B to SD card\n", ICM_buffer_len);
#endif
               }
#ifdef DEBUG
               UARTprintf("i: %d\n", i);
#endif
               ICM_bufferB_empty = true;
               ICM_storage_on = false;
           }
           else if(ICM_buffer_mode == ICM_BUFFER_B) { // if B is currently being used, transfer from A.
#ifdef DEBUG
               UARTprintf("Now writing ICM_Buffer A to SD card\n");
#endif

//               ICM_buffer_len = uint16_len(ICM_bufferA);
//               ICM_buffer_len = ICM_buffer_size * 2;
                rc = f_write(&fil_icm, ICM_bufferA, ICM_buffer_len * 2, &bw); // write to SD Card
//                int i = 0;
//               for (i = 0; i < ICM_buffer_len; i++)
//               {
//                   UARTprintf("%d\t",ICM_bufferA[i]);
//               }

               if(rc != FR_OK)
               {
#ifdef DEBUG
                   UARTprintf("Cannot write to ICM_file! Bye!\n");
#endif
                   return 0;
               }
               else
               {
#ifdef DEBUG
                   UARTprintf("Wrote %d ICM data from ICM_buffer A to SD card\n", ICM_buffer_len);
#endif
               }
#ifdef DEBUG
               UARTprintf("i: %d\n", i);
#endif
               ICM_bufferA_empty = true;
               ICM_storage_on = false;
           }

           if(dummy == 1000){
               dummy = 0;
           }else{
               dummy += 1;
           }//nonsense, added to make the code work

           rc = f_close(&fil_icm);
        }
    }


    UARTprintf("Done! ICM_sample_num = %d\n", ICM_sample_num);
    free(RHS_bufferA);
    free(RHS_bufferB);
    free(ICM_bufferA);
    free(ICM_bufferB);
    f_close(&fil);
    f_close(&fil_icm);
}
