// FSS signal moved from PA6 to PA3
// Move some functions to headstage.h, such as initialization and bandwidth selection code;

// Re-write channel select algorithm; mark result with channel number;

#include <stdint.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include "inc/hw_memmap.h"
#include "driverlib/fpu.h"
#include "driverlib/gpio.h"
#include "driverlib/interrupt.h"
#include "driverlib/pin_map.h"
#include "driverlib/rom.h"
#include "driverlib/sysctl.h"
#include "driverlib/systick.h"
#include "driverlib/timer.h"
#include "driverlib/uart.h"
#include "utils/cmdline.h"
#include "utils/uartstdio.h"
#include "utils/uartstdio.c"
#include "driverlib/adc.h"
#include "driverlib/interrupt.h"
#include "inc/hw_ints.h"
#include "inc/hw_ssi.h"
#include "inc/hw_types.h"
#include "driverlib/debug.h"
#include "driverlib/ssi.h"
#include "ff.h"
#include "diskio.h"
#include "headstage.h"

// Defines for task
#define LED_R GPIO_PIN_7 // red LED
#define LED_G GPIO_PIN_6 // red LED
#define BUFFER_A 0
#define BUFFER_B 1

// buffers for raw data
uint16_t *bufferA;
uint16_t *bufferB;
uint32_t buffer_size;

// variable to keep track of active buffer
volatile bool bufferA_empty;
volatile bool bufferB_empty;
volatile bool buffer_mode;
volatile bool storage_on;

int n;
uint32_t pui32DataRx[1];
uint32_t channel_number;
uint32_t channel[32];

uint16_t count;

uint16_t dummy;


#define DEBUG 1;

// the error routine that is called if the driver library encounters an error
#ifdef DEBUG
void
__error__(char *pcFilename, uint32_t ui32Line)
{
}
#endif

/*Variable required for SD Card R/W*/
FATFS fatfs;
FIL fil;
FRESULT rc;
UINT br, bw;

//track is stimulator is started or not
bool stim_setup = false;
int stim_state[16] = {[0 ... 15] = 0};

/************************************************/
/* stimulation command generated by timer1 */
/************************************************/
uint16_t sti_command_upper;
uint16_t sti_command_lower;

//use new variables for stimulation channel (copy way it's done with recording chan)
uint32_t sti_channel_number;
uint32_t sti_channel[32];

uint32_t stim_period[16];
uint32_t pos_pulse_width[16];
uint32_t neg_pulse_width[16];
uint32_t stim_off_time[16];

uint32_t sti_channel_all_mask = 0;
uint32_t sti_channel_current_mask = 0;

uint32_t sti_channel_masks_arr[16] = {[0 ... 15] = 0};  //array of masks for each channel
uint32_t neg_sti_channel_mask = 0;   //mask for keeping track of stimulators are set negative at any moment
uint32_t on_sti_channel_mask = 0;    //mask for keeping track of stimulators that are on
uint32_t pos_sti_channel_mask = 0;   //mask for keeping track of stimulators are set postive at any moment
uint32_t off_sti_channel_mask = 0;   //mask for keeping track of stimulators that are off


// systick handler for FatFs library
void
SysTickHandler(void)
{
    ROM_SysTickIntDisable();
    disk_timerproc();
    ROM_SysTickIntEnable();
}

// function to send data to headstage
void SPI_Send(uint32_t data_MS, uint32_t data_LS)
{
    // pull-down the FSS signal and delay for some time
    ROM_GPIOPinWrite(GPIO_PORTA_BASE, GPIO_PIN_3, 0);
    ROM_SysCtlDelay(1);

    ROM_SSIDataPut(SSI0_BASE, data_MS);
    ROM_SSIDataPut(SSI0_BASE, data_LS);

    // wait until the data is fully transferred
    while(ROM_SSIBusy(SSI0_BASE))
    {
    }

    // delay for some time and pull-up the FSS signal
    ROM_SysCtlDelay(1);
    ROM_GPIOPinWrite(GPIO_PORTA_BASE, GPIO_PIN_3, 0b0001000);
}

// function to initialize onboard UART.
void uart_init(void)
{
    // enable uart gpio.
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA);

    // configure gpio pins as uart.
    // Port A0 is used for UART data receiving, and A1 is used for UART data transmitting
    ROM_GPIOPinConfigure(GPIO_PA0_U0RX);
    ROM_GPIOPinConfigure(GPIO_PA1_U0TX);

    // enable the uart module.
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_UART0);

    // set clock for baud rate generation.
    ROM_UARTClockSourceSet(UART0_BASE, UART_CLOCK_SYSTEM);

    // set pin type to uart.
    ROM_GPIOPinTypeUART(GPIO_PORTA_BASE, GPIO_PIN_0 | GPIO_PIN_1);

    // configure uart 0 at 115200 bps.
    UARTStdioConfig(0, 115200, SysCtlClockGet());
}


// Timer0 is used for triggering SPI data transfer
void timer0_init(uint32_t frequency)
{
    // Enable the timer peripheral
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_TIMER0);

    // Timer should run periodically
    // Full-width periodic timer
    ROM_TimerConfigure(TIMER0_BASE, TIMER_CFG_PERIODIC);

    // Set the compare value of the timer
    // This corresponds to the sampling frequency
    ROM_TimerLoadSet(TIMER0_BASE, TIMER_A, (ROM_SysCtlClockGet()/frequency)-1);

    // Enable the timer interrupt
    ROM_TimerIntEnable(TIMER0_BASE, TIMER_TIMA_TIMEOUT);
    ROM_IntEnable(INT_TIMER0A);

    // Enable Timer0
    ROM_TimerEnable(TIMER0_BASE, TIMER_A);

}

// Timer1 is used for delivering stimulation for first channel
// Timer1 load should be manually set
void timer1_init(void)
{
    // Enable the timer peripheral
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_TIMER1);

    // Timer should run periodically
    // Full-width periodic timer
    ROM_TimerConfigure(TIMER1_BASE, TIMER_CFG_PERIODIC);

    // Enable the timer interrupt
    ROM_TimerIntEnable(TIMER1_BASE, TIMER_TIMA_TIMEOUT);
    ROM_IntEnable(INT_TIMER1A);
}
// Timer2 is used for delivering stimulation for second channel
// Timer2 load should be manually set
void timer2_init(void)
{
    // Enable the timer peripheral
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_TIMER2);

    // Timer should run periodically
    // Full-width periodic timer
    ROM_TimerConfigure(TIMER2_BASE, TIMER_CFG_PERIODIC);

    // Enable the timer interrupt
    ROM_TimerIntEnable(TIMER2_BASE, TIMER_TIMA_TIMEOUT);
    ROM_IntEnable(INT_TIMER2A);
}
// Timer3 is used for delivering stimulation for third channel
// Timer3 load should be manually set
void timer3_init(void)
{
    // Enable the timer peripheral
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_TIMER3);

    // Timer should run periodically
    // Full-width periodic timer
    ROM_TimerConfigure(TIMER3_BASE, TIMER_CFG_PERIODIC);

    // Enable the timer interrupt
    ROM_TimerIntEnable(TIMER3_BASE, TIMER_TIMA_TIMEOUT);
    ROM_IntEnable(INT_TIMER3A);
}
// Timer4 is used for delivering stimulation for fourth channel
// Timer4 load should be manually set
void timer4_init(void)
{
    // Enable the timer peripheral
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_TIMER4);

    // Timer should run periodically
    // Full-width periodic timer
    ROM_TimerConfigure(TIMER4_BASE, TIMER_CFG_PERIODIC);

    // Enable the timer interrupt
    ROM_TimerIntEnable(TIMER4_BASE, TIMER_TIMA_TIMEOUT);
    ROM_IntEnable(INT_TIMER4A);
}


// function to read register value and compare it with expected value
int read_check(uint32_t address, uint32_t expected_value)
{
    uint32_t DataRx_check[1]; // variable for receiving data

    SPI_Send((0b1100000000000000 | address), 0b0000000000000000);

    SPI_Send((0b1100000000000000 | address), 0b0000000000000000);
    // clear the receive FIFO
    while(ROM_SSIDataGetNonBlocking(SSI0_BASE, &pui32DataRx[0]))
    {
        // do nothing
    }

    SPI_Send((0b1100000000000000 | address), 0b0000000000000000);

    // collect the reading result
    ROM_SSIDataGetNonBlocking(SSI0_BASE, &DataRx_check[1]);
    ROM_SSIDataGetNonBlocking(SSI0_BASE, &DataRx_check[0]);

    if(! (DataRx_check[1] == 0x0000) ){
        return 0;
    }else{}
    if(! (DataRx_check[0] == expected_value) ){
        return 0;
    }else{}

    return 1;
}

void read_register(uint32_t address)
{
    uint32_t DataRx_check[1]; // variable for receiving data

    SPI_Send((0b1100000000000000 | address), 0b0000000000000000);

    SPI_Send((0b1100000000000000 | address), 0b0000000000000000);
    // clear the receive FIFO
    while(ROM_SSIDataGetNonBlocking(SSI0_BASE, &pui32DataRx[0]))
    {
        // do nothing
    }

    SPI_Send((0b1100000000000000 | address), 0b0000000000000000);

    // collect the reading result
    ROM_SSIDataGetNonBlocking(SSI0_BASE, &DataRx_check[1]);
    ROM_SSIDataGetNonBlocking(SSI0_BASE, &DataRx_check[0]);

    char filename[16];
    sprintf(filename, "%s%d", "%s", DataRx_check[0]);
    UARTprintf(filename);
    UARTprintf("\n");
}

uint32_t my_read_register(uint32_t address)
{
    uint32_t DataRx_check[1]; // variable for receiving data

    SPI_Send((0b1100000000000000 | address), 0b0000000000000000);

    SPI_Send((0b1100000000000000 | address), 0b0000000000000000);
    // clear the receive FIFO
    while(ROM_SSIDataGetNonBlocking(SSI0_BASE, &pui32DataRx[0]))
    {
        // do nothing
    }

    SPI_Send((0b1100000000000000 | address), 0b0000000000000000);

    // collect the reading result
    ROM_SSIDataGetNonBlocking(SSI0_BASE, &DataRx_check[1]);
    ROM_SSIDataGetNonBlocking(SSI0_BASE, &DataRx_check[0]);
    uint32_t result = DataRx_check[0] + DataRx_check[1];
    return result;

//what is this even for????????????????????
//    char filename[16];
//    sprintf(filename, "%s%d", "%s", DataRx_check[0]);
//    UARTprintf(filename);
//    UARTprintf("\n");
}

// function to initialize SSI module
void SSI_init(void)
{
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_SSI0);

    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA);
    // ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOC);

    ROM_GPIOPinConfigure(GPIO_PA2_SSI0CLK);
    // ROM_GPIOPinConfigure(GPIO_PC4_SSI0FSS);
    ROM_GPIOPinConfigure(GPIO_PA4_SSI0RX);
    ROM_GPIOPinConfigure(GPIO_PA5_SSI0TX);


    // port A3 is used for FSS output
    ROM_GPIOPinTypeGPIOOutput(GPIO_PORTA_BASE, GPIO_PIN_3);
    ROM_GPIOPinWrite(GPIO_PORTA_BASE, GPIO_PIN_3, 0b0001000);


    ROM_GPIOPinTypeSSI(GPIO_PORTA_BASE, GPIO_PIN_5 | GPIO_PIN_4 | GPIO_PIN_2);
    // ROM_GPIOPinTypeSSI(GPIO_PORTC_BASE, GPIO_PIN_4);

    ROM_SSIConfigSetExpClk(SSI0_BASE, ROM_SysCtlClockGet(), SSI_FRF_MOTO_MODE_0, SSI_MODE_MASTER, 10000000, 16);

    ROM_SSIEnable(SSI0_BASE);

    while(ROM_SSIDataGetNonBlocking(SSI0_BASE, &pui32DataRx[0]))
    {
        // clear the receive FIFO
    }
}

// main function
int main(void)
{
    dummy = 0;

    // used for "for" loops
    int j;

    count = 0;

    // buffer for read data from SD Card
    TCHAR read_buffer[32];
    TCHAR *command;
    TCHAR *value;
    TCHAR *channel_value;

    //add for stimulation chan
    TCHAR *sti_channel_value;

    // counter for loops when writing to SD card
    uint32_t store_count;
    uint32_t i = 0;

    // data read from SD card for configuration
    uint32_t read_value;
    uint32_t sampling_frequency;
    uint32_t sampling_frequency_total;
    uint32_t file_seconds;

    uint32_t cutoff_upper;
    uint32_t cutoff_lower;

    //variables to track stimulation data for multiple channels
    uint32_t pos_pulse_width_temp[16];   //in uA
    uint32_t neg_pulse_width_temp[16];   //in uA
    uint32_t stim_period_temp[16];       //in uA
    //Note: treat this as an array of booleans (doesn't work with volatile bool ...)
    uint32_t stim_on[16];/* = {[0 ... 15] = 0}*/

    int pos_pulse_magnitude[16];
    int neg_pulse_magnitude[16];
    int cur_channel = 0;

    char def_filename[16];
    char filename[16];




    // counter for current file
    uint32_t file_counter = 0;

    n = 0x00;

    channel_number = 0;
    sti_channel_number = 0;

    ROM_SysCtlClockSet(SYSCTL_SYSDIV_4 | SYSCTL_USE_PLL | SYSCTL_OSC_INT | SYSCTL_MAIN_OSC_DIS); // 50MHz System Clock

#ifdef DEBUG
    uart_init();
#endif

#ifdef DEBUG
    UARTprintf("OK, let's begin!\n");
#endif

    // initialize channel[32];
    for (j=0; j<=32; j++){
        channel[j] = 33;
    }
    // initialize sti_channel[32];
    for (j=0; j<=32; j++){
        sti_channel[j] = 33;
    }

    /***********************************************************/
    /* SD Card configuration */
    /***********************************************************/
    // configure the systick timer for a 100Hz interrupt. required by the FatFs driver.
    ROM_SysTickPeriodSet(ROM_SysCtlClockGet() / 100);
    SysTickIntRegister(SysTickHandler);
    ROM_SysTickEnable();
    ROM_SysTickIntEnable();

    // Delay a little for SD card to initialise
    ROM_SysCtlDelay(ROM_SysCtlClockGet()/3);

    ROM_GPIOPinTypeGPIOOutput(GPIO_PORTA_BASE, LED_R | LED_G);
    ROM_GPIOPinWrite(GPIO_PORTA_BASE, LED_R, LED_R);
    ROM_GPIOPinWrite(GPIO_PORTA_BASE, LED_G, LED_G);

    // mount the SD Card using logical drive 0.
    rc = f_mount(0, &fatfs);

    if(rc != FR_OK)
    {
#ifdef DEBUG
        UARTprintf("f_mount error\n");
#endif
        return 0;
    }
    else
    {
#ifdef DEBUG
        UARTprintf("f_mount success!\n");
#endif
    }

    /***********************************************************/
    /* get device configuration from SD card*/
    /***********************************************************/
    // open the configuration file
    rc = f_open(&fil, "config.txt", FA_READ);
    if(rc != FR_OK)
    {
#ifdef DEBUG
        UARTprintf("Configuration file doesn't exist. Bye!\n");
#endif
        return 0;
    }
    else
    {
#ifdef DEBUG
        UARTprintf("Configuration file found!\n");
#endif
        // get configuration parameters
        // about f_eof:  #define f_eof(fp) (((fp)->fptr == (fp)->fsize) ? 1 : 0)
        //&fil is the pointer to the current position?
        while(!f_eof(&fil)) {
            f_gets((char *)read_buffer, sizeof(read_buffer), &fil);
            command = strtok(read_buffer, ":"); //strtok function breaks string into a series of tokens using a delimiter
            value = strtok(NULL, ":");
            if(strcmp(command, "sampling_frequency") == 0) {
                read_value = strtol(value, NULL,10); //strtol function converts string to integer
#ifdef DEBUG
                UARTprintf("sampling_frequency:%d\n", read_value);
#endif
                sampling_frequency = read_value;
            }
            else if(strcmp(command, "buffer_size") == 0) {
                read_value = strtol(value, NULL,10);
#ifdef DEBUG
                UARTprintf("buffer_size:%d\n", read_value);
#endif
                buffer_size = read_value; // this value is number of bytes (8-bit)
                buffer_size = buffer_size/2; // as we are using 16-bit data, we divide by two;
#ifdef DEBUG
                UARTprintf("adjusted buffer_size:%d\n", buffer_size);
#endif
            }
            else if(strcmp(command, "file_seconds") == 0) {
                read_value = strtol(value, NULL,10);
#ifdef DEBUG
                UARTprintf("file_seconds:%d\n", read_value);
#endif
                file_seconds = read_value;
            }
            else if(strcmp(command, "filename") == 0) {
                value[strlen(value)-2] = '\0';
#ifdef DEBUG
                UARTprintf("length of filename:%d\n", strlen(value));
#endif
                strcpy(def_filename, value);
#ifdef DEBUG
                UARTprintf("filename:%s\n", def_filename);
#endif
            }
            else if(strcmp(command, "cutoff_upper") == 0) {
                read_value = strtol(value, NULL,10);
#ifdef DEBUG
                UARTprintf("cutoff_upper:%d\n", read_value);
#endif
                cutoff_upper = read_value;
            }
            else if(strcmp(command, "cutoff_lower") == 0) {
                read_value = strtol(value, NULL,10);
#ifdef DEBUG
                UARTprintf("cutoff_lower:%d\n", read_value);
#endif
                cutoff_lower = read_value;
            }
            else if(strcmp(command, "channel") == 0) {
                // value: 1,2,3,4 break it into single integers
                channel_value = strtok(value, ",");
                j = 0;
                while(channel_value != NULL)
                {
                    channel[j] = strtol(channel_value, NULL, 10);
                    j += 1;

                    channel_value = strtok(NULL, ",");
                }
                j = 0;
#ifdef DEBUG
                while(channel[j] != 33)
                {
                    UARTprintf("Sampling_channel:%d\n", channel[j]);
                    j += 1;
                }
#endif
            }
            //***********Stimulator 0 ***********//
            else if(strcmp(command, "stimulator0_") == 0) {
                if(strncmp(value, "on",2) == 0){
                    stim_on[cur_channel] = 1;
#ifdef DEBUG
                    UARTprintf("Stimulator is on\n");
#endif
                }else{
                    stim_on[cur_channel] = 0;
#ifdef DEBUG
                    UARTprintf("Stimulator is off\n");
#endif
                }
            }
            else if(strcmp(command, "sti_channel0_") == 0) {
                // value: 1,2,3,4 break it into single integers
                read_value = strtol(value, NULL,10);
                sti_channel[cur_channel] = read_value;
            }
            else if(strcmp(command, "stim_period0(us)") == 0) {
                read_value = strtol(value, NULL,10);

#ifdef DEBUG
                UARTprintf("Stimulation_period:%d\n", read_value);
#endif
                stim_period_temp[cur_channel] = read_value;
            }
            else if(strcmp(command, "pos_pulse_magnitude0(nA)") == 0) {
                read_value = strtol(value, NULL,10);
#ifdef DEBUG
                UARTprintf("Positive_pulse_width:%d\n", read_value);
#endif
                pos_pulse_magnitude[cur_channel] = read_value;
            }
            else if(strcmp(command, "pos_pulse_width0(us)") == 0) {
                read_value = strtol(value, NULL,10);
#ifdef DEBUG
                UARTprintf("Positive_pulse_width:%d\n", read_value);
#endif
                pos_pulse_width_temp[cur_channel] = read_value;
            }
            else if(strcmp(command, "neg_pulse_magnitude0(nA)") == 0) {
                read_value = strtol(value, NULL,10);
#ifdef DEBUG
                UARTprintf("Positive_pulse_width:%d\n", read_value);
#endif
                neg_pulse_magnitude[cur_channel] = read_value;
            }
            else if(strcmp(command, "neg_pulse_width0(us)") == 0) {
                read_value = strtol(value, NULL,10);
#ifdef DEBUG
                UARTprintf("Negative_pulse_width:%d\n", read_value);
#endif
                neg_pulse_width_temp[cur_channel] = read_value;
                //update the current channel count for the next channel
                cur_channel++;
            }
            //***********Stimulator 1 ***********//
            else if(strcmp(command, "stimulator1_") == 0) {
                if(strncmp(value, "on",2) == 0){
                    stim_on[cur_channel] = 1;
#ifdef DEBUG
                    UARTprintf("Stimulator is on\n");
#endif
                }else{
                    stim_on[cur_channel] = 0;
#ifdef DEBUG
                    UARTprintf("Stimulator is off\n");
#endif
                }
            }
            else if(strcmp(command, "sti_channel1_") == 0) {
                // value: 1,2,3,4 break it into single integers
                read_value = strtol(value, NULL,10);
                sti_channel[cur_channel] = read_value;
            }
            else if(strcmp(command, "stim_period1(us)") == 0) {
                read_value = strtol(value, NULL,10);

#ifdef DEBUG
                UARTprintf("Stimulation_period:%d\n", read_value);
#endif
                stim_period_temp[cur_channel] = read_value;
            }
            else if(strcmp(command, "pos_pulse_magnitude1(nA)") == 0) {
                read_value = strtol(value, NULL,10);
#ifdef DEBUG
                UARTprintf("Positive_pulse_width:%d\n", read_value);
#endif
                pos_pulse_magnitude[cur_channel] = read_value;
            }
            else if(strcmp(command, "pos_pulse_width1(us)") == 0) {
                read_value = strtol(value, NULL,10);
#ifdef DEBUG
                UARTprintf("Positive_pulse_width:%d\n", read_value);
#endif
                pos_pulse_width_temp[cur_channel] = read_value;
            }
            else if(strcmp(command, "neg_pulse_magnitude1(nA)") == 0) {
                read_value = strtol(value, NULL,10);
#ifdef DEBUG
                UARTprintf("Positive_pulse_width:%d\n", read_value);
#endif
                neg_pulse_magnitude[cur_channel] = read_value;
            }
            else if(strcmp(command, "neg_pulse_width1(us)") == 0) {
                read_value = strtol(value, NULL,10);
#ifdef DEBUG
                UARTprintf("Negative_pulse_width:%d\n", read_value);
#endif
                neg_pulse_width_temp[cur_channel] = read_value;
                //update the current channel count for the next channel
                cur_channel++;
            }

            //***********Stimulator 2 ***********//
            else if(strcmp(command, "stimulator2_") == 0) {
                if(strncmp(value, "on",2) == 0){
                    stim_on[cur_channel] = 1;
#ifdef DEBUG
                    UARTprintf("Stimulator is on\n");
#endif
                }else{
                    stim_on[cur_channel] = 0;
#ifdef DEBUG
                    UARTprintf("Stimulator is off\n");
#endif
                }
            }
            else if(strcmp(command, "sti_channel2_") == 0) {
                // value: 1,2,3,4 break it into single integers
                read_value = strtol(value, NULL,10);
                sti_channel[cur_channel] = read_value;
            }
            else if(strcmp(command, "stim_period2(us)") == 0) {
                read_value = strtol(value, NULL,10);

#ifdef DEBUG
                UARTprintf("Stimulation_period:%d\n", read_value);
#endif
                stim_period_temp[cur_channel] = read_value;
            }
            else if(strcmp(command, "pos_pulse_magnitude2(nA)") == 0) {
                read_value = strtol(value, NULL,10);
#ifdef DEBUG
                UARTprintf("Positive_pulse_width:%d\n", read_value);
#endif
                pos_pulse_magnitude[cur_channel] = read_value;
            }
            else if(strcmp(command, "pos_pulse_width2(us)") == 0) {
                read_value = strtol(value, NULL,10);
#ifdef DEBUG
                UARTprintf("Positive_pulse_width:%d\n", read_value);
#endif
                pos_pulse_width_temp[cur_channel] = read_value;
            }
            else if(strcmp(command, "neg_pulse_magnitude2(nA)") == 0) {
                read_value = strtol(value, NULL,10);
#ifdef DEBUG
                UARTprintf("Positive_pulse_width:%d\n", read_value);
#endif
                neg_pulse_magnitude[cur_channel] = read_value;
            }
            else if(strcmp(command, "neg_pulse_width2(us)") == 0) {
                read_value = strtol(value, NULL,10);
#ifdef DEBUG
                UARTprintf("Negative_pulse_width:%d\n", read_value);
#endif
                neg_pulse_width_temp[cur_channel] = read_value;
                //update the current channel count for the next channel
                cur_channel++;
            }
            //***********Stimulator 3 ***********//
            else if(strcmp(command, "stimulator3_") == 0) {
                if(strncmp(value, "on",2) == 0){
                    stim_on[cur_channel] = 1;
#ifdef DEBUG
                    UARTprintf("Stimulator is on\n");
#endif
                }else{
                    stim_on[cur_channel] = 0;
#ifdef DEBUG
                    UARTprintf("Stimulator is off\n");
#endif
                }
            }
            else if(strcmp(command, "sti_channel3_") == 0) {
                // value: 1,2,3,4 break it into single integers
                read_value = strtol(value, NULL,10);
                sti_channel[cur_channel] = read_value;
            }
            else if(strcmp(command, "stim_period3(us)") == 0) {
                read_value = strtol(value, NULL,10);

#ifdef DEBUG
                UARTprintf("Stimulation_period:%d\n", read_value);
#endif
                stim_period_temp[cur_channel] = read_value;
            }
            else if(strcmp(command, "pos_pulse_magnitude3(nA)") == 0) {
                read_value = strtol(value, NULL,10);
#ifdef DEBUG
                UARTprintf("Positive_pulse_width:%d\n", read_value);
#endif
                pos_pulse_magnitude[cur_channel] = read_value;
            }
            else if(strcmp(command, "pos_pulse_width3(us)") == 0) {
                read_value = strtol(value, NULL,10);
#ifdef DEBUG
                UARTprintf("Positive_pulse_width:%d\n", read_value);
#endif
                pos_pulse_width_temp[cur_channel] = read_value;
            }
            else if(strcmp(command, "neg_pulse_magnitude3(nA)") == 0) {
                read_value = strtol(value, NULL,10);
#ifdef DEBUG
                UARTprintf("Positive_pulse_width:%d\n", read_value);
#endif
                neg_pulse_magnitude[cur_channel] = read_value;
            }
            else if(strcmp(command, "neg_pulse_width3(us)") == 0) {
                read_value = strtol(value, NULL,10);
#ifdef DEBUG
                UARTprintf("Negative_pulse_width:%d\n", read_value);
#endif
                neg_pulse_width_temp[cur_channel] = read_value;
                //update the current channel count for the next channel
                cur_channel++;
            }
            else {
#ifdef DEBUG
                UARTprintf("wrong command\n");
#endif
            }
        }
        f_close(&fil);
    }
    //SET THE CHANNELS HERE BECAUSE READING FROM FILE IS FAILING
//    int k;
//    for(k = 0; k < 4; k++){
//            channel[k] = k;
//    }
//    for(k = 4; k < 16; k++){
//            channel[k] = k;
//    }
    /***********************************************************/
    /* set device configuration*/
    /***********************************************************/
    // set current filename in use
    sprintf(filename, "%s%d.txt", def_filename, file_counter);

    // set up buffers
    bufferA = (uint16_t *)malloc(buffer_size*sizeof(uint16_t));
    bufferB = (uint16_t *)malloc(buffer_size*sizeof(uint16_t));

    // initial config
    buffer_mode = BUFFER_A; // first start from buffer A
    storage_on = false; // currently write to SD card is disabled
    bufferA_empty = true; // buffer is empty
    bufferB_empty = true;   // buffer is empty

    // calculate the required total sampling frequency
    j = 0;
    while (channel[j] != 33)
    {
        channel_number += 1;
        j += 1;
    }
    //get channel_number for stimulation channel
    j = 0;
    while (sti_channel[j] != 33)
    {
        sti_channel_number += 1;
        j += 1;
    }
#ifdef DEBUG
    UARTprintf("Number of stimulation channels:%d\n", sti_channel_number);
#endif
#ifdef DEBUG
    UARTprintf("Total channel number:%d\n", channel_number);
#endif

    sampling_frequency_total = channel_number * sampling_frequency;
#ifdef DEBUG
    UARTprintf("Total sampling frequency:%d\n", sampling_frequency_total);
#endif

    // number of times complete buffer should be written to the SD card
    // to match the duration specified by file_minutes and
    // using 16-bit data (12-bit ADC resolution)
    store_count = (file_seconds * sampling_frequency_total) / buffer_size;
#ifdef DEBUG
    UARTprintf("Store count in each file: %d\n", store_count);
#endif

    SSI_init();
    /***********************************************************/
    /* Initialize the headstage */
    /***********************************************************/

    if(headstage_init() == 0){
#ifdef DEBUG
        UARTprintf("Headstage cannot be initialized. Bye!\n");
#endif
        // return 0;
    }else{
#ifdef DEBUG
        UARTprintf("Headstage successfully initialized!\n");
#endif
    }

    /***********************************************************/
    /* Check the register values */
    /***********************************************************/
    if(headstage_init_check() == 1){
#ifdef DEBUG
        UARTprintf("Register values checked!\n");
#endif
    }else{
#ifdef DEBUG
        UARTprintf("Register values are not as expected. Bye!\n");
#endif
        // return 0;
    }

    /***********************************************************/
    /* Check the register 1 specifically */
    /***********************************************************/
    if(read_check(1, 0x051A) == 1){
#ifdef DEBUG
        UARTprintf("Register 1 checked!\n");
#endif
    }else{
#ifdef DEBUG
        UARTprintf("Register 1 value is not as expected, it's:\n");
        read_register(1);
#endif
        // return 0;
    }

    // re-write the register 0 to set ADC & MUX bias, according to the desired sampling rate
    Frequency_set(sampling_frequency_total);
    // check register 0 value
    if(register0_check(sampling_frequency_total) == 1){
#ifdef DEBUG
        UARTprintf("Register 0 value checked!\n");
#endif
    }else{
#ifdef DEBUG
        UARTprintf("Register 0 value is not as expected, it's:\n");
        read_register(0);
#endif
        // return 0;
    }

    // re-write register 4,5,6
    if (Bandwidth_set(cutoff_upper, cutoff_lower) == 1){
#ifdef DEBUG
        UARTprintf("Bandwidth set!\n");
#endif
    }else{
        UARTprintf("Unable to set bandwidth!\n");
    }

    if (register4_check(cutoff_upper) == 1){
#ifdef DEBUG
        UARTprintf("Register 4 checked!\n");
#endif
    }else{
#ifdef DEBUG
        UARTprintf("Unable to set register 4, bye!\n");
#endif
        // return 0;
    }

    if (register5_check(cutoff_upper) == 1){
#ifdef DEBUG
        UARTprintf("Register 5 checked!\n");
#endif
    }else{
#ifdef DEBUG
        UARTprintf("Unable to set register 5, bye!\n");
#endif
        // return 0;
    }

    if (register6_check(cutoff_lower) == 1){
#ifdef DEBUG
        UARTprintf("Register 6 checked!\n");
#endif
    }else{
#ifdef DEBUG
        UARTprintf("Unable to set register 6, bye!\n");
#endif
        // return 0;
    }

    //**********************************************************/
    /* Initialize the Stimulator */
    //**********************************************************/

    // set magnitude
    // positive stimulation, register 96-111
    //step_val = sti_magnitude/step_size;

    //initialize all stimulation channels
    int k = 0;
    for(k = 0; k < sti_channel_number; k++){
        SPI_Send((0b1010000000000000 + 96 + sti_channel[k]), (0b1000000000000000 + (pos_pulse_magnitude[k]/10000)));
        while(ROM_SSIDataGetNonBlocking(SSI0_BASE, &pui32DataRx))
        {
        }
        // negative stimulation, register 64-79
        //step_val = sti_magnitude/step_size;
        SPI_Send((0b1010000000000000 + 64 + sti_channel[k]), (0b1000000000000000 + (neg_pulse_magnitude[k]/10000)));
        while(ROM_SSIDataGetNonBlocking(SSI0_BASE, &pui32DataRx))
        {
        }
    }
    // re-write register 32 and 33, enable stimulator
    SPI_Send(0b1011000000100000, 0xAAAA); // M = 1, U = 1
    while(ROM_SSIDataGetNonBlocking(SSI0_BASE, &pui32DataRx))
    {
    }
    SPI_Send(0b1010000000100001, 0x00FF);
    while(ROM_SSIDataGetNonBlocking(SSI0_BASE, &pui32DataRx))
    {
    }

    // re-write register 42, ensure all the stimulators are off
    SPI_Send(0b1011000000101010, 0);
    while(ROM_SSIDataGetNonBlocking(SSI0_BASE, &pui32DataRx))
    {
    }

    //update the global variables here (note that we need to do this for the code to work)
    //Note: this only works at this location! don't try moving it anywhere else
    k = 0;
    for(k = 0; k < sti_channel_number; k++){
        pos_pulse_width[k]= pos_pulse_width_temp[k];
        //UARTprintf("pos_pulse_width:%d\n", pos_pulse_width[k]);
        neg_pulse_width[k]= neg_pulse_width_temp[k];
        //UARTprintf("neg_pulse_width:%d\n", neg_pulse_width[k]);
        stim_period[k] = stim_period_temp[k];
        //UARTprintf("stim_period:%d\n", stim_period[k]);
        //calculate the stimulation off duration
        stim_off_time[k] = stim_period[k] - (pos_pulse_width[k] + neg_pulse_width[k]);
    }

    //initilize the channel_masks array
    k = 0;
    for(k = 0; k < sti_channel_number; k++){
        sti_channel_masks_arr[k] = 1 << sti_channel[k];
    }
    //UARTprintf("delay\n");
    k = 0;
    for(k = 0; k < sti_channel_number; k++){
        sti_channel_all_mask = (sti_channel_all_mask | 1 << sti_channel[k]);
    }
//    // turn on stimulator for each channel
//        //sti_command_lower = 1<<sti_channel[k];
//        sti_command_lower = sti_channel_all_mask;
//        sti_command_upper = 0b1010000000101010;
//        //timer1_state += 1;
//        // send the command
//        SPI_Send(sti_command_upper, sti_command_lower);
//        while(ROM_SSIDataGetNonBlocking(SSI0_BASE, &pui32DataRx))
//        {
//        }
    //    UARTprintf("another delay\n");
    /***********************************************************/
    /* Enable global interrupt */
    /***********************************************************/
    ROM_IntMasterEnable();

    timer0_init(sampling_frequency_total);

    timer1_init();
    timer2_init();
    timer3_init();
    timer4_init();
    //turn on corresponding stimulators
    if(stim_on[0]){
        ROM_TimerEnable(TIMER1_BASE, TIMER_A);
    }
    if(stim_on[1]){
        ROM_TimerEnable(TIMER2_BASE, TIMER_A);
    }
    if(stim_on[2]){
        ROM_TimerEnable(TIMER3_BASE, TIMER_A);
    }
    if(stim_on[3]){
        ROM_TimerEnable(TIMER4_BASE, TIMER_A);
    }
    //Timer 1 load
    ROM_TimerLoadSet(TIMER1_BASE, TIMER_A, (ROM_SysCtlClockGet()/10000-1));
    //Timer 2 load
    ROM_TimerLoadSet(TIMER2_BASE, TIMER_A, (ROM_SysCtlClockGet()/10000-1));
    //Timer 3 load
    ROM_TimerLoadSet(TIMER3_BASE, TIMER_A, (ROM_SysCtlClockGet()/10000-1));
    //Timer 4 load
    ROM_TimerLoadSet(TIMER4_BASE, TIMER_A, (ROM_SysCtlClockGet()/10000-1));

    /***********************************************************/
    /* Open first file to write */
    /***********************************************************/
    rc = f_open(&fil, filename, FA_CREATE_ALWAYS | FA_WRITE);
    if(rc != FR_OK)
    {
#ifdef DEBUG
        UARTprintf("Cannot open file for writing data. Bye!\n");
#endif
        return 0;
    }
    else
    {
#ifdef DEBUG
        UARTprintf("Now writing to file: %s\n", filename);
#endif
    }


    // ROM_GPIOPinWrite(GPIO_PORTA_BASE, LED_R, LED_R); // turn off red LED
    /***********************************************************/
    /* Main application loop */
    /***********************************************************/
    //ROM_TimerLoadSet(TIMER1_BASE, TIMER_A, (ROM_SysCtlClockGet()/100-1));

    while(1){
        if(storage_on) { // check if write to SD card is enabled
            //ROM_TimerLoadSet(TIMER1_BASE, TIMER_A, (ROM_SysCtlClockGet()-1));

            // ROM_GPIOPinWrite(GPIO_PORTA_BASE, LED_G, 0);

            // check if storecount for the file matches store-count.
            // if it matches, we must close this file and create a new file for writing to
            // ROM_GPIOPinWrite(GPIO_PORTA_BASE, LED_G, LED_G);
            if(i == store_count) {
                //ROM_TimerLoadSet(TIMER1_BASE, TIMER_A, (ROM_SysCtlClockGet()/100-1));

                f_close(&fil); // close the open file
                file_counter = file_counter + 1; // increment the counter
                i = 0;
                sprintf(filename, "%s%d.txt", def_filename, file_counter); // generate new filename

                rc = f_open(&fil, filename, FA_CREATE_ALWAYS | FA_WRITE); // open the new file
                if(rc != FR_OK)
                {
#ifdef DEBUG
                    UARTprintf("Cannot open file for writing data. Bye!\n");
#endif
                    return 0;
                }
                else
                {
#ifdef DEBUG
                    UARTprintf("Now writing to file: %s\n", filename);
#endif
                }
            }else{
                //do nothing
            }

            // ROM_GPIOPinWrite(GPIO_PORTA_BASE, LED_G, 0);
            if(buffer_mode == BUFFER_A) { // if A is currently being used, transfer from B
#ifdef DEBUG
                UARTprintf("Now writing Buffer B\n");
#endif
                // ROM_GPIOPinWrite(GPIO_PORTA_BASE, LED_G, 0);
                rc = f_write(&fil, bufferB, buffer_size*2, &bw); // write to SD Card
                if(rc != FR_OK)
                {
#ifdef DEBUG
                    UARTprintf("Cannot write to file! Bye!\n");
#endif
                    return 0;
                }
                else
                {
                    // ROM_GPIOPinWrite(GPIO_PORTA_BASE, LED_G, LED_G);
#ifdef DEBUG
                    UARTprintf("Wrote buffer B\n");
#endif
                }
                i = i + 1;
#ifdef DEBUG
                UARTprintf("i: %d\n", i);
#endif
                bufferB_empty = true;
                storage_on = false;
            }
            else if(buffer_mode == BUFFER_B) { // if B is currently being used, transfer from A.
#ifdef DEBUG
                UARTprintf("Now writing Buffer A\n");
#endif
                // ROM_GPIOPinWrite(GPIO_PORTA_BASE, LED_G, 0);
                rc = f_write(&fil, bufferA, buffer_size*2, &bw); // write to SD Card
                if(rc != FR_OK)
                {
#ifdef DEBUG
                    UARTprintf("Cannot write to file! Bye!\n");
#endif
                    return 0;
                }
                else
                {
                    // ROM_GPIOPinWrite(GPIO_PORTA_BASE, LED_G, LED_G);
#ifdef DEBUG
                    UARTprintf("Wrote buffer A\n");
#endif
                }
                i = i + 1;
#ifdef DEBUG
                UARTprintf("i: %d\n", i);
#endif
                bufferA_empty = true;
                storage_on = false;
            }
            // ROM_GPIOPinWrite(GPIO_PORTA_BASE, LED_G, LED_G);

            if(dummy == 1000){
                dummy = 0;
            }else{
                dummy += 1;
            }//nonsense, added to make the code work
        }
        else {
            ROM_SysCtlSleep();
        }
    }
}

// Handler for timer0
void Timer0IntHandler(void) {
    //setup in the timer0 interrupt to make the code work

    // clear the timer interrupt
    ROM_TimerIntClear(TIMER0_BASE, TIMER_TIMA_TIMEOUT);
    //ROM_TimerLoadSet(TIMER1_BASE, TIMER_A, (ROM_SysCtlClockGet()/1000000)-1); // re-set timer1 load

    uint32_t ADCValue[1];

    static uint16_t channel_count = 0;

    // do one convert
    SPI_Send(channel[channel_count], 0);

    if(channel_count < channel_number-1){
        channel_count += 1;
    }else{
        channel_count = 0;
    }

    // read conversion result from FIFO
    ROM_SSIDataGetNonBlocking(SSI0_BASE, &ADCValue[0]); //high gain amplifier result
    ROM_SSIDataGetNonBlocking(SSI0_BASE, &ADCValue[1]);

    if(bufferA_empty || bufferB_empty) { // check if any buffer is empty or has space
        if(buffer_mode == BUFFER_A) {
            bufferA[count] = ADCValue[0];
        }
        else if(buffer_mode == BUFFER_B) {
            bufferB[count] = ADCValue[0];
        }

        count = count + 1; // increment count for data in buffer
        if(count == buffer_size) { // check if count equals buffer_size, or if the buffer is full
            count = 0;

            // switch buffer mode and enable storage on SD card
            if(buffer_mode == BUFFER_A)
            {
                buffer_mode = BUFFER_B;
                bufferA_empty = false;
                storage_on = true;
            }
            else if(buffer_mode == BUFFER_B) {
                buffer_mode = BUFFER_A;
                bufferB_empty = false;
                storage_on = true;
            }
        }
    }

    // nonsense, added to make the code work
    if(bufferA_empty || bufferB_empty) { // check if any buffer is empty or has space
        if(buffer_mode == BUFFER_A) {
            bufferA[count] = ADCValue[0];
        }
        else if(buffer_mode == BUFFER_B) {
            bufferB[count] = ADCValue[0];
        }
    }
}

// Handler for timer1
void Timer1IntHandler(void) {
    ROM_TimerIntClear(TIMER1_BASE, TIMER_TIMA_TIMEOUT);
    //UARTprintf("Inside Timer 1\n\n\n\n\n\n");
    //ROM_TimerLoadSet(TIMER1_BASE, TIMER_A, (ROM_SysCtlClockGet()-1));
    uint32_t result;
        switch(stim_state[0]){
        case 0:
            //toggle stimulation polarity to negative
            //clear bit in sti_command_lower
            result = my_read_register(44);
            //UARTprintf("result is:%d\n\n", result);
            result = (result & ~sti_channel_masks_arr[0]);
            sti_command_lower = result;
            sti_command_upper = 0b1010000000101100;
            SPI_Send(sti_command_upper, sti_command_lower);
            while(ROM_SSIDataGetNonBlocking(SSI0_BASE, &pui32DataRx))
            {
            }
            // turn on stimulator
            //set bits in sti_command_lower
            result = my_read_register(42);
            result = (result | sti_channel_masks_arr[0]);
            //uint32_t channels_command = (1 << sti_channel[0])| (1 << sti_channel[1]);
            sti_command_lower = result;
            sti_command_upper = 0b1010000000101010;
            SPI_Send(sti_command_upper, sti_command_lower);
            while(ROM_SSIDataGetNonBlocking(SSI0_BASE, &pui32DataRx))
            {
            }
           // int pos_pulse_width = pos_pulse_width_temp;
            //UARTprintf("pos_pulse_width = %d\n\n",pos_pulse_width);
            ROM_TimerLoadSet(TIMER1_BASE, TIMER_A, (ROM_SysCtlClockGet()/1000000)*neg_pulse_width[0]-1);
            stim_state[0]++;
            break;
        case 1:
            // toggle stimulation polarity to positive
            //set bits in sti_command_lower
            result = my_read_register(44);
            result = (result | sti_channel_masks_arr[0]);
            sti_command_lower = result;
            sti_command_upper = 0b1010000000101100;
            SPI_Send(sti_command_upper, sti_command_lower);
            while(ROM_SSIDataGetNonBlocking(SSI0_BASE, &pui32DataRx))
            {
            }
            ROM_TimerLoadSet(TIMER1_BASE, TIMER_A, (ROM_SysCtlClockGet()/1000000)*pos_pulse_width[0]-1);
            stim_state[0]++;
            break;
        case 2 :
            // turn off stimulator
            // clear bits in sti_command_lower
            result = my_read_register(42);
            result = (result & ~sti_channel_masks_arr[0]);
            sti_command_lower = result;
            sti_command_upper = 0b1010000000101010;
            SPI_Send(sti_command_upper, sti_command_lower);
            while(ROM_SSIDataGetNonBlocking(SSI0_BASE, &pui32DataRx))
            {
            }
            ROM_TimerLoadSet(TIMER1_BASE, TIMER_A, (ROM_SysCtlClockGet()/1000000)*stim_off_time[0]-1);
            stim_state[0] = 0;
            break;
        default:
            //nothing
        }
}
//// Handler for timer2
//void Timer2IntHandler(void) {
//    ROM_TimerIntClear(TIMER2_BASE, TIMER_TIMA_TIMEOUT);
//    //UARTprintf("Inside Timer 1\n\n\n\n\n\n");
//    //ROM_TimerLoadSet(TIMER1_BASE, TIMER_A, (ROM_SysCtlClockGet()-1));
//    UARTprintf("In timer 2\n\n\n\n\n");
//    ROM_TimerLoadSet(TIMER2_BASE, TIMER_A, (ROM_SysCtlClockGet()/1000000)*stim_off_time[0]-1);
//}
// Handler for timer2
void Timer2IntHandler(void) {
    ROM_TimerIntClear(TIMER2_BASE, TIMER_TIMA_TIMEOUT);
    //UARTprintf("Inside Timer 2\n\n\n\n\n\n");
    //ROM_TimerLoadSet(TIMER2_BASE, TIMER_A, (ROM_SysCtlClockGet()-1));
    uint32_t result;
        switch(stim_state[1]){
        case 0:
            //toggle stimulation polarity to negative
            //clear bit in sti_command_lower
            result = my_read_register(44);
            result = (result & ~sti_channel_masks_arr[1]);
            sti_command_lower = result;
            sti_command_upper = 0b1010000000101100;
            SPI_Send(sti_command_upper, sti_command_lower);
            while(ROM_SSIDataGetNonBlocking(SSI0_BASE, &pui32DataRx))
            {
            }
            // turn on stimulator
            //set bits in sti_command_lower
            result = my_read_register(42);
            result = (result | sti_channel_masks_arr[1]);
            //uint32_t channels_command = (1 << sti_channel[0])| (1 << sti_channel[1]);
            sti_command_lower = result;
            sti_command_upper = 0b1010000000101010;
            SPI_Send(sti_command_upper, sti_command_lower);
            while(ROM_SSIDataGetNonBlocking(SSI0_BASE, &pui32DataRx))
            {
            }
           // int pos_pulse_width = pos_pulse_width_temp;
            //UARTprintf("pos_pulse_width = %d\n\n",pos_pulse_width);
            ROM_TimerLoadSet(TIMER2_BASE, TIMER_A, (ROM_SysCtlClockGet()/1000000)*neg_pulse_width[1]-1);
            stim_state[1]++;
            break;
        case 1:
            // toggle stimulation polarity to positive
            //set bits in sti_command_lower
            result = my_read_register(44);
            result = (result | sti_channel_masks_arr[1]);
            sti_command_lower = result;
            sti_command_upper = 0b1010000000101100;
            SPI_Send(sti_command_upper, sti_command_lower);
            while(ROM_SSIDataGetNonBlocking(SSI0_BASE, &pui32DataRx))
            {
            }
            ROM_TimerLoadSet(TIMER2_BASE, TIMER_A, (ROM_SysCtlClockGet()/1000000)*pos_pulse_width[1]-1);
            stim_state[1]++;
            break;
        case 2 :
            // turn off stimulator
            // clear bits in sti_command_lower
            result = my_read_register(42);
            result = (result & ~sti_channel_masks_arr[1]);
            sti_command_lower = result;
            sti_command_upper = 0b1010000000101010;
            SPI_Send(sti_command_upper, sti_command_lower);
            while(ROM_SSIDataGetNonBlocking(SSI0_BASE, &pui32DataRx))
            {
            }
            ROM_TimerLoadSet(TIMER2_BASE, TIMER_A, (ROM_SysCtlClockGet()/1000000)*stim_off_time[1]-1);
            stim_state[1] = 0;
            break;
        default:
            //nothing
        }
}
// Handler for timer3
void Timer3IntHandler(void) {
    ROM_TimerIntClear(TIMER3_BASE, TIMER_TIMA_TIMEOUT);
    //UARTprintf("Inside Timer 2\n\n\n\n\n\n");
    //ROM_TimerLoadSet(TIMER2_BASE, TIMER_A, (ROM_SysCtlClockGet()-1));
    uint32_t result;
        switch(stim_state[2]){
        case 0:
            //toggle stimulation polarity to negative
            //clear bit in sti_command_lower
            result = my_read_register(44);
            result = (result & ~sti_channel_masks_arr[2]);
            sti_command_lower = result;
            sti_command_upper = 0b1010000000101100;
            SPI_Send(sti_command_upper, sti_command_lower);
            while(ROM_SSIDataGetNonBlocking(SSI0_BASE, &pui32DataRx))
            {
            }
            // turn on stimulator
            //set bits in sti_command_lower
            result = my_read_register(42);
            result = (result | sti_channel_masks_arr[2]);
            //uint32_t channels_command = (1 << sti_channel[0])| (1 << sti_channel[1]);
            sti_command_lower = result;
            sti_command_upper = 0b1010000000101010;
            SPI_Send(sti_command_upper, sti_command_lower);
            while(ROM_SSIDataGetNonBlocking(SSI0_BASE, &pui32DataRx))
            {
            }
           // int pos_pulse_width = pos_pulse_width_temp;
            //UARTprintf("pos_pulse_width = %d\n\n",pos_pulse_width);
            ROM_TimerLoadSet(TIMER3_BASE, TIMER_A, (ROM_SysCtlClockGet()/1000000)*neg_pulse_width[2]-1);
            stim_state[2]++;
            break;
        case 1:
            // toggle stimulation polarity to positive
            //set bits in sti_command_lower
            result = my_read_register(44);
            result = (result | sti_channel_masks_arr[2]);
            sti_command_lower = result;
            sti_command_upper = 0b1010000000101100;
            SPI_Send(sti_command_upper, sti_command_lower);
            while(ROM_SSIDataGetNonBlocking(SSI0_BASE, &pui32DataRx))
            {
            }
            ROM_TimerLoadSet(TIMER3_BASE, TIMER_A, (ROM_SysCtlClockGet()/1000000)*pos_pulse_width[2]-1);
            stim_state[2]++;
            break;
        case 2 :
            // turn off stimulator
            // clear bits in sti_command_lower
            result = my_read_register(42);
            result = (result & ~sti_channel_masks_arr[2]);
            sti_command_lower = result;
            sti_command_upper = 0b1010000000101010;
            SPI_Send(sti_command_upper, sti_command_lower);
            while(ROM_SSIDataGetNonBlocking(SSI0_BASE, &pui32DataRx))
            {
            }
            ROM_TimerLoadSet(TIMER3_BASE, TIMER_A, (ROM_SysCtlClockGet()/1000000)*stim_off_time[2]-1);
            stim_state[2] = 0;
            break;
        default:
            //nothing
        }
}
// Handler for timer4
void Timer4IntHandler(void) {
    ROM_TimerIntClear(TIMER4_BASE, TIMER_TIMA_TIMEOUT);
    //UARTprintf("Inside Timer 2\n\n\n\n\n\n");
    //ROM_TimerLoadSet(TIMER2_BASE, TIMER_A, (ROM_SysCtlClockGet()-1));
    uint32_t result;
        switch(stim_state[3]){
        case 0:
            //toggle stimulation polarity to negative
            //clear bit in sti_command_lower
            result = my_read_register(44);
            result = (result & ~sti_channel_masks_arr[3]);
            sti_command_lower = result;
            sti_command_upper = 0b1010000000101100;
            SPI_Send(sti_command_upper, sti_command_lower);
            while(ROM_SSIDataGetNonBlocking(SSI0_BASE, &pui32DataRx))
            {
            }
            // turn on stimulator
            //set bits in sti_command_lower
            result = my_read_register(42);
            result = (result | sti_channel_masks_arr[3]);
            //uint32_t channels_command = (1 << sti_channel[0])| (1 << sti_channel[1]);
            sti_command_lower = result;
            sti_command_upper = 0b1010000000101010;
            SPI_Send(sti_command_upper, sti_command_lower);
            while(ROM_SSIDataGetNonBlocking(SSI0_BASE, &pui32DataRx))
            {
            }
           // int pos_pulse_width = pos_pulse_width_temp;
            //UARTprintf("pos_pulse_width = %d\n\n",pos_pulse_width);
            ROM_TimerLoadSet(TIMER4_BASE, TIMER_A, (ROM_SysCtlClockGet()/1000000)*neg_pulse_width[3]-1);
            stim_state[3]++;
            break;
        case 1:
            // toggle stimulation polarity to positive
            //set bits in sti_command_lower
            result = my_read_register(44);
            result = (result | sti_channel_masks_arr[3]);
            sti_command_lower = result;
            sti_command_upper = 0b1010000000101100;
            SPI_Send(sti_command_upper, sti_command_lower);
            while(ROM_SSIDataGetNonBlocking(SSI0_BASE, &pui32DataRx))
            {
            }
            ROM_TimerLoadSet(TIMER4_BASE, TIMER_A, (ROM_SysCtlClockGet()/1000000)*pos_pulse_width[3]-1);
            stim_state[3]++;
            break;
        case 2 :
            // turn off stimulator
            // clear bits in sti_command_lower
            result = my_read_register(42);
            result = (result & ~sti_channel_masks_arr[3]);
            sti_command_lower = result;
            sti_command_upper = 0b1010000000101010;
            SPI_Send(sti_command_upper, sti_command_lower);
            while(ROM_SSIDataGetNonBlocking(SSI0_BASE, &pui32DataRx))
            {
            }
            ROM_TimerLoadSet(TIMER4_BASE, TIMER_A, (ROM_SysCtlClockGet()/1000000)*stim_off_time[3]-1);
            stim_state[3] = 0;
            break;
        default:
            //nothing
        }
}
